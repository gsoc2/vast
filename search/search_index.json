{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VAST: MLIR for Program Analysis","text":"<p>VAST is a library for program analysis and instrumentation of C/C++ and related languages. VAST provides a foundation for customizable program representation for a broad spectrum of analyses. Using the MLIR infrastructure, VAST provides a toolset to represent C/C++ program at various stages of the compilation and to transform the representation to the best-fit program abstraction.</p> <p>Whether static or dynamic, program analysis often requires a specific view of the source code. The usual requirements for a representation is to be easily analyzable, i.e., have a reasonably small set of operations, be truthful to the semantics of the analyzed program, and the analysis must be relatable to the source. It is also beneficial to access the source at various abstraction levels.</p> <p>The current state-of-the-art tools leverage compiler infrastructures to perform program analysis. This approach is beneficial because it remains truthful to the executed program semantics, whether AST or LLVM IR. However, these representations come at a cost as they are designed for optimization and code generation, rather than for program analysis.</p> <p>The Clang AST is unoptimized and too complex for interpretation-based analysis. Also, it lacks program features that Clang inserts during its LLVM code generation process. On the other hand, LLVM is often too low-level and hard to relate to high-level program constructs.</p> <p>VAST is a new compiler front/middle-end designed for program analysis. It transforms parsed C and C++ code, in the form of Clang ASTs, into a high-level MLIR dialect. The high level dialect is then progressively lowered all the way down to LLVM IR. This progression enables VAST to represent the code as a tower of IRs in multiple MLIR dialects. The MLIR allows us to capture high-level features from AST and interleave them with low-level dialects.</p>"},{"location":"#a-tower-of-irs","title":"A Tower of IRs","text":"<p>The feature that differentiates our approach is that the program representation can hold multiple representations simultaneously, the so-called <code>tower of IRs</code>. One can imagine the tower as multiple MLIR modules side-by-side in various dialects. Each layer of the tower represents a specific stage of compilation. At the top is a high-level dialect relatable to AST, and at the bottom is a low-level LLVM-like dialect. Layers are interlinked with location information. Higher layers can also be seen as metadata for lower layers.</p> <p>This feature simplifies analysis built on top of VAST IR in multiple ways. It naturally provides provenance to higher levels dialects (and source code) from the low levels. Similarly, one can reach for low-level representation from the high-level source view. This can have multiple utilizations.  One of them is relating analysis results to the source. For a user, it is invaluable to represent results in the language of what they see, that is, the high-level representation of the source. For example, using provenance, one can link the values in low-level registers to variable names in the source.  Furthermore, this streamlines communication from the user to the analysis backend and back in the interactive tools and also allows the automatic analysis to query the best-fit representation at any time.</p> <p>The provenance is invaluable for static analysis too. It is often advantageous to perform analysis as an abstract interpretation of the low-level representation and relate it to high-level constructs. For example, when trying to infer properties about control flow, like loop invariants, one can examine high-level operations and relate the results to low-level analysis using provenance links.</p> <p>We expect to provide a DSL library for design of custom program representation abstraction on top of our tower of IRs. The library will provide utilities to link other dialects to the rest of the tower so that the provenance is usable outside the main pipeline.</p>"},{"location":"#dialects","title":"Dialects","text":"<p>As a foundation, VAST provides backbone dialects for the tower of IRs. A high-level dialect <code>hl</code> is a faithful representation of Clang AST. While intermediate dialects represent compilation artifacts like ABI lowering of macro expansions. Whenever it is possible, we try to utilize standard dialects. At the bottom of the tower, we have the <code>llvm</code> dialect. For features that are not present in the <code>llvm</code> dialect, we utilize our low-level dialect <code>ll</code>. We leverage a <code>meta</code> dialect to provide provenance utilities. The currently supported features are documented in automatically generated dialect docs.</p> <p>For types, we provide high-level types from Clang AST enriched by value categories. This allows referencing types as presented in the source. In the rest of the tower, we utilize standard or llvm types, respectively.</p> <p>One does not need to utilize the tower of IRs but can craft a specific representation that interleaves multiple abstractions simultaneously.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to VAST","text":"<p>First, thanks for your interest in contributing to VAST! We welcome and appreciate all contributions, including bug reports, feature suggestions, tutorials/blog posts, and code improvements.</p> <p>If you're unsure where to start, we recommend our <code>good first issue</code> issue label.</p>"},{"location":"CONTRIBUTING/#bug-reports-and-feature-suggestions","title":"Bug reports and feature suggestions","text":"<p>Bug reports and feature suggestions can be submitted to our issue tracker.</p> <p>When reporting a bug please provide a minimal example with steps to reproduce the issue if possible. It helps us a lot, as we can get to the bottom of the issue much faster and can even use it as a test case to catch future regressions.</p>"},{"location":"CONTRIBUTING/#questions","title":"Questions","text":"<p>Questions can be submitted to the discussion page.</p>"},{"location":"CONTRIBUTING/#legal","title":"Legal","text":"<p>For legal reasons, we require contributors to sign our Contributor License Agreement.  This will be automatically checked as part of our CI.</p>"},{"location":"CONTRIBUTING/#git-pull-requests","title":"Git &amp; Pull Requests","text":"<p>VAST uses the pull request contribution model. Please make an account on Github, fork this repo, and submit code contributions via pull request. For more documentation, look here.</p> <p>Since VAST does not squash commits in a pull request, it is important to uphold some culture when it comes to commits.</p> <ul> <li>Commit should ideally be one simple change.</li> <li>Commit messages follow a simple format:   <code>component: Simple sentence with a dot.</code> with maximum of 80 chars and optional longer   message.</li> <li>When unsure what component commit modifies, run <code>git log</code> on the modified file(s).</li> <li>Commits should modify only one component (as a result the project does not have   to build with each separate commit)</li> <li>If you are having troubles coming up with a simple sentence as a commit message,   that is short enough, it may be a good indicator that the commit should be split.</li> </ul> <p>Some pull request guidelines:</p> <ul> <li>Minimize irrelevant changes (formatting, whitespace, etc) to code that would   otherwise not be touched by this patch. Save formatting or style corrections   for a separate pull request that does not make any semantic changes.</li> <li>When possible, large changes should be split up into smaller focused pull   requests.</li> <li>Fill out the pull request description with a summary of what your patch does,   key changes that have been made, and any further points of discussion, if   applicable.</li> <li>Title your pull request with a brief description of what it's changing.   \"Fixes #123\" is a good comment to add to the description, but makes for an   unclear title on its own.</li> <li>CI must pass for the PR to be merged.</li> <li>There must be a review from some maintainer that accepts changes for the PR to be merged.</li> </ul>"},{"location":"statement/","title":"License","text":"<p>VAST is licensed according to the Apache 2.0 license. VAST links against and uses Clang and LLVM APIs. Clang is also licensed under Apache 2.0, with LLVM exceptions.</p> <p>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA). The views, opinions and/or findings expressed are those of the author and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p> <p>Distribution Statement A \u2013 Approved for Public Release, Distribution Unlimited</p>"},{"location":"Designs/abi/","title":"Abi","text":""},{"location":"Designs/abi/#abi","title":"ABI","text":"<p>VAST partially models ABI specifications for function types and therefore callsites. While the specification goes into details regarding registers, for now VAST only offers lowering similar to what clang codegen does - argument and return types are coerced to types that will easily fit their respective registers once that allocation takes place. There is nothing preventing inclusion of information about registers as well (for example as metadata or separate operations/dialect), however it is not yet implemented.</p> <p>Similar to other transformation in VAST, ABI modelling tries to be as modular as possible and as such can be split into three distinct steps:</p> <ul> <li>Compute classification of types</li> <li>Encode computed classification into module</li> <li>Lower transformed module into some \"executable\" dialect</li> </ul> <p>Main goal for now is to lower function prototypes to match the types produced by clang, so that VAST emitted LLVM can be used as drop-in replacement for clang one.</p> <p>When reading this document please keep in mind that implementation of this feature is still ongoing and therefore particular technical details could change drastically (although we hope that overall design will remain the same).</p>"},{"location":"Designs/abi/#classification","title":"Classification","text":"<p>Mirrors what clang does, but instead of locking the computed information away, we expose the API. In ideal world we would like to keep the algorithm(s, as there may be multiple per different ABIs) generic. This can be achieved by requiring users to implement &amp; provide interface that specifies various details about used types; algorithm will be same when talking about <code>hl</code> or <code>LLVM</code> types after all.</p>"},{"location":"Designs/abi/#abi-dialect","title":"ABI Dialect","text":"<p>Once classification for a function is computed, we need to:</p> <ul> <li>Change function prototype</li> <li>Encode how new types match to the old types + some oddities such as <code>sret</code>.</li> </ul> <p>To facilitate this, VAST contains <code>abi</code> dialect, which operations encode \"high-level\" descriptions of type transformations that can occur during ABI lowering as operations. This is not very different from what clang does, but VAST does it over multiple steps.</p> <p>For functions, type change itself is easy and to mark that function is transformed, <code>abi.func</code> operation is used instead of original one to define the newly formed function. However, as arguments and return types are different, we introduce <code>abi.prologue</code> and <code>abi.epilogue</code> operations.</p> <p>Consider following function we want to lower:</p> <p>Disclaimer: Since <code>abi</code> dialect does not have nice formatting, therefore examples in this section contain some artistic liberty, but semantics (and operations) are preserved.</p> <pre><code>strut Point{ int; int; int; };\n\nint size( struct Point p ) { ... }\n</code></pre> <p>After running the classification, we discover that type of <code>size</code> should be <code>( i64, i32 ) -&gt; i32</code> - both arguments and returned value are passed directly. Therefore we encode it as follows:</p> <pre><code>abi.func size(i64 %arg0_0, i32 %arg0_1 ) -&gt; i32\n{\n    %arg = abi.prologue -&gt; hl.lvalue&lt; hl.struct&lt; \"Point\" &gt; &gt;\n    {\n        %0 = abi.direct %arg0_0, %arg0_1: (i64, i32) -&gt; hl.struct&lt; \"Point\" &gt;\n        abi.yield %0\n    }\n\n    // Computation can continue as before, because %arg has a correct type\n\n    %ret = ... value that was previously returned ... -&gt; i32\n    %out = abi.epilogue\n    {\n        %0 = abi.direct %ret: i32 -&gt; i32\n        abi.yield %0\n    }\n    hl.return %out\n}\n</code></pre> <p>In case, there were multiple function arguments, the <code>abi.prologue</code> would return more values.</p> <pre><code>\n%args = abi.prologue -&gt; (hl.lvalue&lt; hl.struct&lt; \"Point\" &gt; &gt;, i32 )\n{\n    %0 = abi.direct %arg0_0, %arg0_1\n    %1 = abi.direct %arg1\n    abi.yield %0, %1\n}\n</code></pre> <p>TODO: Add extra examples, at least <code>memory</code> and <code>sret</code>.</p> <p>This design allows easy analysis and subsequent rewrite (as each function has a prologue and epilogue and returned values are explicitly yielded).</p> <p>Callsites are transformed in the same manner (unfortunately, they look more complicated due to nested regions):</p> <pre><code>\n%x = hl.call&lt; \"size\" &gt; %arg: hl.struct&lt; \"Point\" &gt; -&gt; i32\n\n%x = abi.call&lt; \"size\" &gt;: () -&gt; i32\n{\n    %arg0_0, %arg0_1 = abi.call_args: () -&gt; (i64, i32)\n    {\n        %0, %1 = abi.direct %arg\n        abi.yield %0, %1\n    }\n    %x' = hl.call&lt; \"size\" &gt; %arg0_0, &amp;arg0_1 : (i64, i32) -&gt; i32\n    %0 = abi.call_rets : () -&gt; i32\n    {\n        %0 = abi.direct %x' : i32 -&gt; i32\n        abi.yield %0\n    }\n    abi.yield %0\n}\n\n</code></pre> <p>For now, same <code>abi</code> operations are used to encode transformation in callsite and function (although they change the value in a \"opposite direction\"), this may be later revisited, but for now it is enough to look at the parent operation to determine whether the transformation lies in a function or callsite.</p>"},{"location":"Designs/abi/#lowering-to-some-executable-dialect","title":"Lowering to some executable dialect","text":"<p>While <code>abi</code> dialect provides us with all the information required to do the transformation, it does not \"compute\" anything. Rather this lowering is left to a next pass. We hope by splitting the transformation into 2, we achieve the following:</p> <ul> <li>We can implement multiple \"backends\" - whether back to <code>hl</code>, <code>llvm</code> or totally   random dialect of user choice.</li> <li>Re-use existing implementation of classification algorithm.</li> </ul>"},{"location":"Designs/cpp2-parameters/","title":"Cpp2 parameters","text":""},{"location":"Designs/cpp2-parameters/#lifting-parameter-passing-httpsgithubcomhsutter708blobmain708pdf","title":"Lifting parameter passing [https://github.com/hsutter/708/blob/main/708.pdf]","text":"<p>The proposed way of parameter passing for next-gen c++ is to use declarative style:</p> <pre><code>f(     in X x) // x can be read from\nf(  inout X x) // x can be used in read and write\nf(    out X x) // x can be writen to\nf(   move X x) // x will be moved from\nf(forward X x) // x will be passed along\n</code></pre> <p>Similar holds for return values:</p> <pre><code>auto f()    move X { /* ... */ } // move X to caller\nauto f()         X { /* ... */ } // possibly same\nauto f() forward X { /* ... */ } // pass along X to the caller\n</code></pre> <p>Using the semantics aware vast dialects, we can design a method to automatically modernize code to use a declarative style of parameter passing.</p>"},{"location":"Designs/cpp2-parameters/#examples","title":"Examples","text":"CPP   CPP2  <pre>\nvoid f(const X&amp; x) {\n    g(x);\n}\n</pre> <pre>\nvoid f(in X x) {\n    g(x);\n}\n</pre>  VAST high-level dialect   Transformed to parameter dialect  <pre>\nhl.func @f(%x: !hl.ref&lt; !hl.lvalue&lt; !hl.struct&lt; \"X\" &gt; &gt;, const &gt;) {\n    %0 = hl.call @g(%x) : (!hl.ref&lt; !hl.lvalue&lt; !hl.struct&lt; \"X\" &gt; &gt;, const &gt;) -&gt; !hl.void\n}\n</pre> <pre>\nhl.func @f(%x: !par.in&lt; !hl.lvalue&lt; !hl.struct&lt; \"X\" &gt; &gt; &gt;) {\n    %0 = hl.call @g(%x) : (!par.in&lt; !hl.lvalue&lt; !hl.struct&lt; \"X\" &gt; &gt; &gt;) -&gt; !hl.void\n}\n</pre> <p>The transformation will be probably overapproximating, in cases when the analysis cannot determine the precise category, i.e., <code>inout</code> oveapproximates <code>in</code> and <code>out</code> parameters.</p>"},{"location":"Designs/cpp2-parameters/#dialect","title":"Dialect","text":"<p>The dialect will define type adaptors for each parameter category:</p> <pre><code>!par.in&lt; T &gt;\n!par.out&lt; T &gt;\n!par.inout&lt; T &gt;\n!par.move&lt; T &gt;\n!par.forward&lt; T &gt;\n</code></pre> <p>Parameter categories can also be present as type attributes not to mess up the rest of the type trait system. This needs further investigation.</p> <p>The advantage of the type adaptors we can enforce the correct usage of values. For example, we can forbid usage of <code>out</code> parameter in other places than assignment.</p>"},{"location":"GettingStarted/build/","title":"Build & Run","text":""},{"location":"GettingStarted/build/#dependencies","title":"Dependencies","text":"<p>Currently, it is necessary to use <code>clang</code> (due to <code>gcc</code> bug) to build VAST. On Linux it is also necessary to use <code>lld</code> at the moment.</p> <p>VAST uses <code>llvm-17</code> which can be obtained from the repository provided by LLVM.</p> <p>Before building (for Ubuntu) get all the necessary dependencies by running</p> <pre><code>apt-get install build-essential cmake ninja-build libstdc++-12-dev llvm-17 libmlir-17 libmlir-17-dev mlir-17-tools libclang-17-dev\n</code></pre> <p>or an equivalent command for your operating system of choice.</p>"},{"location":"GettingStarted/build/#instructions","title":"Instructions","text":"<p>To configure project run <code>cmake</code> with following default options. In case <code>clang</code> isn't your default compiler prefix the command with <code>CC=clang CXX=clang++</code>. If you want to use system installed <code>llvm</code> and <code>mlir</code> (on Ubuntu) use:</p> <pre><code>cmake --preset ninja-multi-default \\\n    --toolchain ./cmake/lld.toolchain.cmake \\\n    -DCMAKE_PREFIX_PATH=/usr/lib/llvm-17/\n</code></pre> <p>To use a specific <code>llvm</code> provide <code>-DCMAKE_PREFIX_PATH=&lt;llvm &amp; mlir instalation paths&gt;</code> option, where <code>CMAKE_PREFIX_PATH</code> points to directory containing <code>LLVMConfig.cmake</code> and <code>MLIRConfig.cmake</code>.</p> <p>Note: vast requires LLVM with RTTI enabled. Use <code>LLVM_ENABLE_RTTI=ON</code> if you build your own LLVM.</p> <p>Finally, build the project:</p> <pre><code>cmake --build --preset ninja-rel\n</code></pre> <p>Use <code>ninja-deb</code> preset for debug build.</p>"},{"location":"GettingStarted/build/#run","title":"Run","text":"<p>To run mlir codegen of highlevel dialect use.</p> <pre><code>./builds/ninja-multi-default/tools/vast-front/Release/vast-front -vast-emit-mlir=&lt;dialect&gt; &lt;input.c&gt; -o &lt;output.mlir&gt;\n</code></pre> <p>Supported dialects are: <code>hl</code>, <code>ll</code>, <code>llvm</code></p>"},{"location":"GettingStarted/build/#test","title":"Test","text":"<pre><code>ctest --preset ninja-deb\n</code></pre>"},{"location":"GettingStarted/extend/","title":"How to create a new dialect","text":""},{"location":"GettingStarted/extend/#how-to-start-extending-vast","title":"How to Start Extending VAST?","text":"<p>VAST offers a handy script to generate a variety of MLIR primitives. You can find the script at scripts/templater.py. This tool is designed to help you create dialects, passes, operations, types, and attributes interactively.</p>"},{"location":"GettingStarted/extend/#usage","title":"Usage","text":"<p>Just run the script. It has been designed to provide a guided process for generating the desired primitives. If you find anything confusing or unintuitive, please don't hesitate to open an issue so that we can address it.</p> <p>When you run the script, it will generate the basic skeleton for your chosen primitive. It will list the generated files which you can freely modify to provide desired functionality.</p>"},{"location":"Tools/vast-front/","title":"VAST: Compiler Driver","text":"<p>WIP <code>vast-front</code></p>"},{"location":"Tools/vast-lsp-server/","title":"VAST: Language Server Protocol","text":"<p>VAST provides an implementation of LSP language server in the form of the <code>vast-lsp-server</code> tool. This tool interacts with the MLIR C++ API to support rich language queries, such as \u201cFind Definition\u201d.</p> <p>The tool easily integrates with VSCode extension MLIR. The user needs to point the extension to <code>mlir-lsp-server</code>. To do so, one can create a symbolic link named <code>mlir-lsp-server</code> to point to built <code>vast-lsp-server</code>.</p>"},{"location":"Tools/vast-lsp-server/#build","title":"Build","text":"<p>To build <code>vast-lsp-server</code> use:</p> <pre><code>cmake --build &lt;build-dir&gt; --target vast-lsp-server\n</code></pre>"},{"location":"Tools/vast-opt/","title":"VAST: Optimizer","text":"<p>After <code>mlir</code> module from <code>vast-cc</code> is produced, we can leverage our optimisation pipeline to transform module in various ways. The lowest level we can do is LLVM dialect, from which we can dump LLVM IR if desired.</p> <p>Overall design philosophy is that passes try to be really modular, self-contained and doing one thing properly - all while trying to preserve provenance metadata. Sometimes this does not exactly hold (transformation from <code>HL</code> into <code>LL</code> is huge) but it is what we strive for. Passes will more often than not have some dependencies between themselves - always consult documentation if unsure and report an issue if wiki is out of date on this.</p>"},{"location":"Tools/vast-opt/#metadata-and-passes","title":"Metadata and passes","text":"<p>TODO: Improve once we have examples</p> <p>TL;DR: Vast provided passes always try to keep metadata (and they should do a good job), but for passes from other sources this does not hold and probably some heuristic will be used to re-compute them in best-effort.</p>"},{"location":"Tools/vast-opt/#passes","title":"Passes","text":"<p>Passes we have implemented can be roughly grouped into several categories. We also note some of the native mlir passes that are needed to continue with transformations to reach LLVM dialect.</p>"},{"location":"Tools/vast-opt/#type-lowering","title":"Type lowering","text":"<p>A common prerequisite for other passes is to lower <code>HL</code> types into standard types. This can be done in two steps:  * <code>--vast-hl-lower-types</code>    - Converts simple (non-struct) types according to provided data layout (embedded in the mlir module metadata).  * <code>--vast-hl-structs-to-tuples</code>    - Converts <code>HL</code> struct types into standard tuples</p> <p>While these should be commutative, the preferred order is <code>--vast-hl-lower-types --vast-hl-structs-to-tuples</code></p>"},{"location":"Tools/vast-opt/#hl-scf","title":"HL -&gt; SCF","text":"<ul> <li><code>--vast-hl-to-scf</code></li> <li>Requires:<ul> <li>Type lowering</li> </ul> </li> <li>Conversion of <code>HL</code> control flow ops (currently only <code>hl.if</code> and <code>hl.while</code>) into their <code>scf</code> equivalents. Since <code>scf</code> requires <code>i1</code> in their conditions, additional casts may be inserted to satisfy this requirement (currently they are emitted in <code>HL</code> however this behaviour should customisable eventually.</li> </ul> <p>To produce an LLVM following addition passes must be run <code>--convert-scf-to-std --convert-std-to-llvm</code> and possibly <code>--vast-hl-to-ll</code> as well (or some equivalent, depending on how conditions are coerced)</p>"},{"location":"Tools/vast-opt/#hl-ll","title":"HL -&gt; LL","text":"<ul> <li><code>--vast-hl-to-ll</code></li> <li>Requires:<ul> <li>Type lowering</li> <li>Some form of control flow lowering</li> </ul> </li> <li>Lower all <code>HL</code> operation into their LLVM dialect equivalents - this is a rather huge pass, for details see its documentation.</li> </ul>"},{"location":"Tools/vast-opt/#llvm-dump","title":"LLVM Dump","text":"<ul> <li><code>--vast-llvm-dump</code></li> <li>Requires:<ul> <li>Entire module must be in LLVM dialect (or have operation for which conversion hooks are provided)</li> </ul> </li> <li>LLVM bitcode is dumped to <code>llvm::errs()</code> in human readable form. Since passes can run in parallel, dump to file is non-trivial.</li> </ul>"},{"location":"Tools/vast-opt/#example-usage","title":"Example Usage","text":"<p>Let's say we have file <code>main.c</code> which we want to lower into some dialect. First let's have a look at some generic invocations we may find handy:</p> <p>To get mlir module via <code>vast-cc</code></p> <pre><code>vast-cc --ccopts -xc --from-source main.c\n</code></pre> <p>A quick remainder  * <code>--ccopts -xc</code> says we are doing <code>C</code> not <code>C++</code>  * <code>--from-source file</code> says that source code comes from the file</p> <p>Once we have the module, we can invoke <code>vast-opt</code>, with easiest way being a simple pipe</p> <pre><code>vast-cc --ccopts -xc --from-source main.c | vast-opt pass-we-want another-pass-we-want\n</code></pre> <p>If we want, we can also chain pipes</p> <pre><code>vast-cc --ccopts -xc --from-source main.c | vast-opt pass | vast-opt another-pass | ...\n</code></pre> <p>Now, let's say we want to lower into LLVM bitcode, therefore the invocation will look as follows</p> <pre><code>vast-cc --ccopts -xc --from-source main.c | vast-opt --vast-hl-lower-types --vast-hl-structs-to-tuples\n                                                     --vast-hl-to-scf --convert-scf-to-std --convert-std-to-llvm\n                                                     --vast-hl-to-ll\n</code></pre>"},{"location":"Tools/vast-query/","title":"VAST: Query","text":"<p><code>vast-query</code> is a command line tool to query symbols in the vast generated MLIR. Its primary purpose is to test symbols and their use edges in the produced MLIR. Example of usage:</p> <pre><code>vast-query [options] &lt;input file&gt;\n</code></pre> <p>Options:</p> <pre><code>  --scope=&lt;function name&gt;      - Show values from scope of a given function\n  --show-symbols=&lt;value&gt;       - Show MLIR symbols\n    =functions                 -   show function symbols\n    =types                     -   show type symbols\n    =records                   -   show record symbols\n    =vars                      -   show variable symbols\n    =globs                     -   show global variable symbols\n    =all                       -   show all symbols\n  --symbol-users=&lt;symbol name&gt; - Show users of a given symbol\n</code></pre>"},{"location":"Tools/vast-repl/","title":"VAST: REPL","text":"<p>WIP <code>vast-repl</code> is an interactive MLIR query and modification tool.</p> <p>Commands:</p> <pre><code>exit            - exits repl\n\nhelp            - prints help\nload &lt;filename&gt; - loads source from file\n\nshow &lt;value&gt;    - displays queried value\n    =source         - loaded source code\n    =ast            - clang ast\n    =module         - current VAST MLIR module\n    =symbols        - present symbols in the module\n\nmeta &lt;action&gt;   - operates on metadata for given symbol\n    =add &lt;symbol&gt; &lt;id&gt; - adds &lt;id&gt; meta to &lt;symbol&gt;\n    =get &lt;id&gt;          - gets symbol with &lt;id&gt; meta\n</code></pre>"},{"location":"dialects/HighLevelPasses/","title":"High Level","text":""},{"location":"dialects/HighLevelPasses/#-vast-export-fn-info","title":"<code>-vast-export-fn-info</code>","text":"<p>Create JSON that exports information about function arguments.</p> <p>Lowers module into llvm IR and dumps it on stderr.</p>"},{"location":"dialects/HighLevelPasses/#options","title":"Options","text":"<pre><code>-o : Output JSON file to be created.\n</code></pre>"},{"location":"dialects/HighLevelPasses/#-vast-hl-canonicalize","title":"<code>-vast-hl-canonicalize</code>","text":"<p>Canonicalize hl dialect.</p> <p>This pass inserts returns with void values where missing and removes surplus skips.</p>"},{"location":"dialects/HighLevelPasses/#-vast-hl-dce","title":"<code>-vast-hl-dce</code>","text":"<p>Trim dead code</p> <p>Removes unreachable code, such as code after return or break/continue.</p>"},{"location":"dialects/HighLevelPasses/#-vast-hl-lower-typedefs","title":"<code>-vast-hl-lower-typedefs</code>","text":"<p>Replace <code>hl::TypeDef</code> type by its underlying aliased type.</p> <p>Replaces <code>hl::TypeDef</code> types by its underlying aliased types. The conversion resolves nested typedefs.</p> <p>All <code>hl::TypeDef</code> are marked illegal and converted by this pass.</p>"},{"location":"dialects/HighLevelPasses/#-vast-hl-lower-types","title":"<code>-vast-hl-lower-types</code>","text":"<p>Lower high-level types to standard types</p> <p>Lower high-level types into standard types which is usually required first step by other passes in the pipeline.</p> <p>Information about bit sizes of high level types is inferred from the data layout of the module, which is derived from the information provided by clang and emitted automatically by <code>vast-cc</code>.</p> <p>TODO: Named types are not yet supported.</p>"},{"location":"dialects/HighLevelPasses/#-vast-hl-splice-trailing-scopes","title":"<code>-vast-hl-splice-trailing-scopes</code>","text":"<p>Remove trailing <code>hl::Scope</code>s.</p> <p>Removes trailing scopes.</p>"},{"location":"dialects/LowLevelPasses/","title":"Low Level","text":""},{"location":"dialects/LowLevelPasses/#-vast-ll-to-llvm","title":"<code>-vast-ll-to-llvm</code>","text":"<p>Convert low level operations to LLVM dialect.</p> <p>Work in progess.</p>"},{"location":"dialects/ABI/ABI/","title":"ABI","text":""},{"location":"dialects/ABI/ABI/#abi-dialect","title":"'abi' Dialect","text":"<p>A vast ABI dialect. Dialect provides operations to describe how arguments and return values are transformed to better model target abi.</p> <ul> <li>'abi' Dialect<ul> <li>Operation definition<ul> <li>abi.call (::vast::abi::CallOp)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>abi.call_args (::vast::abi::CallArgsOp)<ul> <li>Results:</li> </ul> </li> <li>abi.call_exec (::vast::abi::CallExecutionOp)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>abi.call_rets (::vast::abi::CallRetsOp)<ul> <li>Results:</li> </ul> </li> <li>abi.direct (::vast::abi::DirectOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>abi.epilogue (::vast::abi::EpilogueOp)<ul> <li>Results:</li> </ul> </li> <li>abi.func (::vast::abi::FuncOp)<ul> <li>Attributes:</li> </ul> </li> <li>abi.prologue (::vast::abi::PrologueOp)<ul> <li>Results:</li> </ul> </li> <li>abi.ret_direct (::vast::abi::RetDirectOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>abi.todo (::vast::abi::TodoOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>abi.wrap_fn (::vast::abi::WrapFuncOp)<ul> <li>Attributes:</li> </ul> </li> <li>abi.yield (::vast::abi::YieldOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"dialects/ABI/ABI/#operation-definition","title":"Operation definition","text":""},{"location":"dialects/ABI/ABI/#abicall-vastabicallop","title":"<code>abi.call</code> (::vast::abi::CallOp)","text":"<p>ABI call operation</p> <p>Syntax:</p> <pre><code>operation ::= `abi.call` $callee `(` $args `)` attr-dict `:` functional-type( $args, $results )\n</code></pre> <p>ABI call operation Interfaces: CallOpInterface</p>"},{"location":"dialects/ABI/ABI/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>callee</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"dialects/ABI/ABI/#operands","title":"Operands:","text":"Operand Description <code>args</code> any type"},{"location":"dialects/ABI/ABI/#results","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"dialects/ABI/ABI/#abicall_args-vastabicallargsop","title":"<code>abi.call_args</code> (::vast::abi::CallArgsOp)","text":"<p>Not implement yet.</p> <p>Syntax:</p> <pre><code>operation ::= `abi.call_args` $body attr-dict `:` type($results)\n</code></pre> <p>WIP</p>"},{"location":"dialects/ABI/ABI/#results_1","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"dialects/ABI/ABI/#abicall_exec-vastabicallexecutionop","title":"<code>abi.call_exec</code> (::vast::abi::CallExecutionOp)","text":"<p>WIP</p> <p>Syntax:</p> <pre><code>operation ::= `abi.call_exec` $callee `(` $args `)` $body attr-dict `:` functional-type($args, $result)\n</code></pre> <p>WIP Interfaces: CallOpInterface</p>"},{"location":"dialects/ABI/ABI/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>callee</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"dialects/ABI/ABI/#operands_1","title":"Operands:","text":"Operand Description <code>args</code> any type"},{"location":"dialects/ABI/ABI/#results_2","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/ABI/ABI/#abicall_rets-vastabicallretsop","title":"<code>abi.call_rets</code> (::vast::abi::CallRetsOp)","text":"<p>Not implement yet.</p> <p>Syntax:</p> <pre><code>operation ::= `abi.call_rets` $body attr-dict `:` type($results)\n</code></pre> <p>WIP</p>"},{"location":"dialects/ABI/ABI/#results_3","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"dialects/ABI/ABI/#abidirect-vastabidirectop","title":"<code>abi.direct</code> (::vast::abi::DirectOp)","text":"<p>Pass value directly - usually means by register</p> <p>Syntax:</p> <pre><code>operation ::= `abi.direct` $value attr-dict `:` type($value) `-&gt;` type($result)\n</code></pre> <p>Pass value directly - usually means by register.</p>"},{"location":"dialects/ABI/ABI/#operands_2","title":"Operands:","text":"Operand Description <code>value</code> any type"},{"location":"dialects/ABI/ABI/#results_4","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/ABI/ABI/#abiepilogue-vastabiepilogueop","title":"<code>abi.epilogue</code> (::vast::abi::EpilogueOp)","text":"<p>WIP</p> <p>Syntax:</p> <pre><code>operation ::= `abi.epilogue` $body attr-dict `:` type($results)\n</code></pre> <p>WIP</p>"},{"location":"dialects/ABI/ABI/#results_5","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"dialects/ABI/ABI/#abifunc-vastabifuncop","title":"<code>abi.func</code> (::vast::abi::FuncOp)","text":"<p>_ Function with transformed type. _</p> <p>Syntax:</p> <pre><code>operation ::= `abi.func` $sym_name custom&lt; FunctionSignatureAndBody &gt;($function_type, attr-dict, $body)\n</code></pre> <p>Placeholder.</p> <p>Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator</p> <p>Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol</p>"},{"location":"dialects/ABI/ABI/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_name</code> ::mlir::StringAttr string attribute <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>linkage</code> ::vast::core::GlobalLinkageKindAttr global linkage kind <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"dialects/ABI/ABI/#abiprologue-vastabiprologueop","title":"<code>abi.prologue</code> (::vast::abi::PrologueOp)","text":"<p>WIP</p> <p>Syntax:</p> <pre><code>operation ::= `abi.prologue` $body attr-dict `:` type($results)\n</code></pre> <p>WIP</p>"},{"location":"dialects/ABI/ABI/#results_6","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"dialects/ABI/ABI/#abiret_direct-vastabiretdirectop","title":"<code>abi.ret_direct</code> (::vast::abi::RetDirectOp)","text":"<p>Value is returned directly.</p> <p>Syntax:</p> <pre><code>operation ::= `abi.ret_direct` $value attr-dict `:` type($value) `-&gt;` type($result)\n</code></pre> <p>Value is returned directly.</p>"},{"location":"dialects/ABI/ABI/#operands_3","title":"Operands:","text":"Operand Description <code>value</code> any type"},{"location":"dialects/ABI/ABI/#results_7","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/ABI/ABI/#abitodo-vastabitodoop","title":"<code>abi.todo</code> (::vast::abi::TodoOp)","text":"<p>Not implement yet.</p> <p>Syntax:</p> <pre><code>operation ::= `abi.todo` $value attr-dict `:` type($value) `-&gt;` type($result)\n</code></pre> <p>Not implemented yet</p>"},{"location":"dialects/ABI/ABI/#operands_4","title":"Operands:","text":"Operand Description <code>value</code> any type"},{"location":"dialects/ABI/ABI/#results_8","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/ABI/ABI/#abiwrap_fn-vastabiwrapfuncop","title":"<code>abi.wrap_fn</code> (::vast::abi::WrapFuncOp)","text":"<p>_ Function that defines abi transformation of args. _</p> <p>Syntax:</p> <pre><code>operation ::= `abi.wrap_fn` $sym_name custom&lt; FunctionSignatureAndBody &gt;($function_type, attr-dict, $body)\n</code></pre> <p>Placeholder.</p> <p>Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator</p> <p>Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol</p>"},{"location":"dialects/ABI/ABI/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_name</code> ::mlir::StringAttr string attribute <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>linkage</code> ::vast::core::GlobalLinkageKindAttr global linkage kind <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"dialects/ABI/ABI/#abiyield-vastabiyieldop","title":"<code>abi.yield</code> (::vast::abi::YieldOp)","text":"<p>WIP</p> <p>Syntax:</p> <pre><code>operation ::= `abi.yield` $values attr-dict `:` type($values) `-&gt;` type($result)\n</code></pre> <p>WIP Traits: Terminator</p>"},{"location":"dialects/ABI/ABI/#operands_5","title":"Operands:","text":"Operand Description <code>values</code> any type"},{"location":"dialects/ABI/ABI/#results_9","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/Core/Core/","title":"Core","text":""},{"location":"dialects/Core/Core/#core-dialect","title":"'core' Dialect","text":"<p>Utility dialect to provide common features for other dialects. Dialect providing features that may be used by other dialects. These features can be used by including \"vast/Dialect/Core/Utils.td\" It also provides lazy.op for lazy evaluation of expressions and binary logical operations that make use of it.</p> <ul> <li>'core' Dialect<ul> <li>Operation definition<ul> <li>core.bin.land (::vast::core::BinLAndOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>core.bin.lor (::vast::core::BinLOrOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>core.implicit.return (::vast::core::ImplicitReturnOp)<ul> <li>Operands:</li> </ul> </li> <li>core.lazy.op (::vast::core::LazyOp)<ul> <li>Results:</li> </ul> </li> <li>core.scope (::vast::core::ScopeOp)</li> <li>core.select (::vast::core::SelectOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> </ul> </li> <li>Attribute definition<ul> <li>BooleanAttr<ul> <li>Parameters:</li> </ul> </li> <li>FloatAttr<ul> <li>Parameters:</li> </ul> </li> <li>IntegerAttr<ul> <li>Parameters:</li> </ul> </li> <li>SourceLanguageAttr<ul> <li>Parameters:</li> </ul> </li> <li>StringLiteralAttr<ul> <li>Parameters:</li> </ul> </li> <li>VoidAttr<ul> <li>Parameters:</li> </ul> </li> </ul> </li> <li>Type definition<ul> <li>FunctionType<ul> <li>Parameters:</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"dialects/Core/Core/#operation-definition","title":"Operation definition","text":""},{"location":"dialects/Core/Core/#corebinland-vastcorebinlandop","title":"<code>core.bin.land</code> (::vast::core::BinLAndOp)","text":"<p>VAST core dialect logical binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `core.bin.land` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>Core dialect logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : type"},{"location":"dialects/Core/Core/#operands","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/Core/Core/#results","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/Core/Core/#corebinlor-vastcorebinlorop","title":"<code>core.bin.lor</code> (::vast::core::BinLOrOp)","text":"<p>VAST core dialect logical binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `core.bin.lor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>Core dialect logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : type"},{"location":"dialects/Core/Core/#operands_1","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/Core/Core/#results_1","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/Core/Core/#coreimplicitreturn-vastcoreimplicitreturnop","title":"<code>core.implicit.return</code> (::vast::core::ImplicitReturnOp)","text":"<p>VAST implicit return</p> <p>Syntax:</p> <pre><code>operation ::= `core.implicit.return` $result `:` type($result) attr-dict\n</code></pre> <p>Op representing return that wasn't explicitely written in the source (e.g. in void fun(){}).</p> <p>Traits: return_trait, soft_terminator</p>"},{"location":"dialects/Core/Core/#operands_2","title":"Operands:","text":"Operand Description <code>result</code> any type"},{"location":"dialects/Core/Core/#corelazyop-vastcorelazyop","title":"<code>core.lazy.op</code> (::vast::core::LazyOp)","text":"<p>Lazily evaluate a region.</p> <p>Syntax:</p> <pre><code>operation ::= `core.lazy.op` $lazy attr-dict `:` type(results)\n</code></pre> <p>The operation serves to encapsulate delayed evaluation in its region.</p> <p>Traits: NoTerminator</p>"},{"location":"dialects/Core/Core/#results_2","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/Core/Core/#corescope-vastcorescopeop","title":"<code>core.scope</code> (::vast::core::ScopeOp)","text":"<p>VAST scope declaration</p> <p>Syntax:</p> <pre><code>operation ::= `core.scope` $body attr-dict\n</code></pre> <p>Scope operation servers to represent explicitly high-level code scope. Other control flow operations represent scopes implicitly.  It is a single-region operation.</p> <p>Traits: NoTerminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/Core/Core/#coreselect-vastcoreselectop","title":"<code>core.select</code> (::vast::core::SelectOp)","text":"<p>Select a value based on condition.</p> <p>Syntax:</p> <pre><code>operation ::= `core.select` $cond `,` $thenRegion `,` $elseRegion attr-dict `:` functional-type(operands, results)\n</code></pre> <p>Usual select operation. First operand is selected if predicate is true, second otherwise (to mirror how ternary works in C).</p> <p>%result =  %cond %lhs, %rhs  : type"},{"location":"dialects/Core/Core/#operands_3","title":"Operands:","text":"Operand Description <code>cond</code> any type <code>thenRegion</code> any type <code>elseRegion</code> any type"},{"location":"dialects/Core/Core/#results_3","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"dialects/Core/Core/#attribute-definition","title":"Attribute definition","text":""},{"location":"dialects/Core/Core/#booleanattr","title":"BooleanAttr","text":"<p>An Attribute containing a boolean value</p> <p>Syntax:</p> <pre><code>#core.bool&lt;\n  ::mlir::Type,   # type\n  bool   # value\n&gt;\n</code></pre> <p>An boolean attribute is a literal attribute that represents a boolean value.</p>"},{"location":"dialects/Core/Core/#parameters","title":"Parameters:","text":"Parameter C++ type Description type <code>::mlir::Type</code> value <code>bool</code>"},{"location":"dialects/Core/Core/#floatattr","title":"FloatAttr","text":"<p>An Attribute containing a floating point value</p> <p>Syntax:</p> <pre><code>#core.float&lt;\n  ::mlir::Type,   # type\n  ::llvm::APFloat   # value\n&gt;\n</code></pre> <p>A float attribute is a literal attribute that represents a floating point value of the specified floating point type.</p>"},{"location":"dialects/Core/Core/#parameters_1","title":"Parameters:","text":"Parameter C++ type Description type <code>::mlir::Type</code> value <code>::llvm::APFloat</code>"},{"location":"dialects/Core/Core/#integerattr","title":"IntegerAttr","text":"<p>An Attribute containing a integer value</p> <p>Syntax:</p> <pre><code>#core.integer&lt;\n  ::mlir::Type,   # type\n  ::llvm::APSInt   # value\n&gt;\n</code></pre> <p>An integer attribute is a literal attribute that represents an integral value of the specified integer type.</p>"},{"location":"dialects/Core/Core/#parameters_2","title":"Parameters:","text":"Parameter C++ type Description type <code>::mlir::Type</code> value <code>::llvm::APSInt</code>"},{"location":"dialects/Core/Core/#sourcelanguageattr","title":"SourceLanguageAttr","text":"<p>Module source language</p> <p>Syntax:</p> <pre><code>#core.lang&lt;\n  ::vast::core::SourceLanguage   # value\n&gt;\n</code></pre> <p>Represents the source language used to generate the module.</p> <p>Example:</p> <pre><code>// Module compiled from C.\nmodule attributes {vast.core.lang = vast.core.lang&lt;c&gt;} {}\n// Module compiled from C++.\nmodule attributes {vast.core.lang = vast.core.lang&lt;cxx&gt;} {}\n</code></pre>"},{"location":"dialects/Core/Core/#parameters_3","title":"Parameters:","text":"Parameter C++ type Description value <code>::vast::core::SourceLanguage</code> an enum of type SourceLanguage"},{"location":"dialects/Core/Core/#stringliteralattr","title":"StringLiteralAttr","text":"<p>An Attribute containing an escaped string</p> <p>Syntax:</p> <pre><code>string-attribute ::= string-literal (`:` type)?\n</code></pre> <p>A string literal attribute is an attribute that represents an escaped string literal value.</p> <p>Examples:</p> <pre><code>\"An important string\"\n\"string with a type\" : !dialect.string\n</code></pre>"},{"location":"dialects/Core/Core/#parameters_4","title":"Parameters:","text":"Parameter C++ type Description value <code>::llvm::StringRef</code> type <code>::mlir::Type</code>"},{"location":"dialects/Core/Core/#voidattr","title":"VoidAttr","text":"<p>Attribute to represent void value.</p> <p>Syntax:</p> <pre><code>#core.void&lt;\n  ::mlir::Type   # type\n&gt;\n</code></pre> <p>The VoidAttr is used to return void from statements uniformly.</p>"},{"location":"dialects/Core/Core/#parameters_5","title":"Parameters:","text":"Parameter C++ type Description type <code>::mlir::Type</code>"},{"location":"dialects/Core/Core/#type-definition","title":"Type definition","text":""},{"location":"dialects/Core/Core/#functiontype","title":"FunctionType","text":"<p>Vast function type</p> <p>Syntax:</p> <pre><code>!core.fn&lt;\n  ::llvm::ArrayRef&lt;Type&gt;,   # inputs\n  ::llvm::ArrayRef&lt;Type&gt;,   # results\n  bool   # varArg\n&gt;\n</code></pre> <p>The <code>!core.fn</code> is a function type. It consists of a variadic return type, and list of parameter types and can optionally be variadic.</p> <p>Example:</p> <pre><code>!core.fn&lt;!hl.bool ()&gt;\n!core.fn&lt;!hl.int (!hl.char, !hl.char)&gt;\n!core.fn&lt;!i32 (!i32, ...)&gt;\n</code></pre>"},{"location":"dialects/Core/Core/#parameters_6","title":"Parameters:","text":"Parameter C++ type Description inputs <code>::llvm::ArrayRef&lt;Type&gt;</code> results <code>::llvm::ArrayRef&lt;Type&gt;</code> varArg <code>bool</code>"},{"location":"dialects/HighLevel/HighLevel/","title":"High Level","text":""},{"location":"dialects/HighLevel/HighLevel/#hl-dialect","title":"'hl' Dialect","text":"<p>A high-level verbose program analysis MLIR dialect. This dialect intends capture highevel constructs of C/C++ for further program analysis.</p> <ul> <li>'hl' Dialect<ul> <li>Operation definition<ul> <li>hl.access (::vast::hl::AccessSpecifierOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.add (::vast::hl::AddIOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.addressof (::vast::hl::AddressOf)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.alignof.expr (::vast::hl::AlignOfExprOp)<ul> <li>Results:</li> </ul> </li> <li>hl.alignof.type (::vast::hl::AlignOfTypeOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>hl.assign (::vast::hl::AssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.add (::vast::hl::AddIAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.bin.and (::vast::hl::BinAndAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.bin.ashr (::vast::hl::BinAShrAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.bin.lshr (::vast::hl::BinLShrAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.bin.or (::vast::hl::BinOrAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.bin.shl (::vast::hl::BinShlAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.bin.xor (::vast::hl::BinXorAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.fadd (::vast::hl::AddFAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.fdiv (::vast::hl::DivFAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.fmul (::vast::hl::MulFAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.frem (::vast::hl::RemFAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.fsub (::vast::hl::SubFAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.mul (::vast::hl::MulIAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.sdiv (::vast::hl::DivSAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.srem (::vast::hl::RemSAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.sub (::vast::hl::SubIAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.udiv (::vast::hl::DivUAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.assign.urem (::vast::hl::RemUAssignOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.base (::vast::hl::CxxBaseSpecifierOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.bin.and (::vast::hl::BinAndOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.bin.ashr (::vast::hl::BinAShrOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.bin.comma (::vast::hl::BinComma)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.bin.land (::vast::hl::BinLAndOp)<ul> <li>Results:</li> </ul> </li> <li>hl.bin.lor (::vast::hl::BinLOrOp)<ul> <li>Results:</li> </ul> </li> <li>hl.bin.lshr (::vast::hl::BinLShrOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.bin.or (::vast::hl::BinOrOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.bin.shl (::vast::hl::BinShlOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.bin.xor (::vast::hl::BinXorOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.break (::vast::hl::BreakOp)</li> <li>hl.builtin_bitcast (::vast::hl::BuiltinBitCastOp)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.call (::vast::hl::CallOp)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.case (::vast::hl::CaseOp)</li> <li>hl.class (::vast::hl::ClassDeclOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.cmp (::vast::hl::CmpOp)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.cond (::vast::hl::CondOp)<ul> <li>Results:</li> </ul> </li> <li>hl.cond.yield (::vast::hl::CondYieldOp)<ul> <li>Operands:</li> </ul> </li> <li>hl.const (::vast::hl::ConstantOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>hl.continue (::vast::hl::ContinueOp)</li> <li>hl.cstyle_cast (::vast::hl::CStyleCastOp)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.cxxstruct (::vast::hl::CxxStructDeclOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.default (::vast::hl::DefaultOp)</li> <li>hl.deref (::vast::hl::Deref)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.do (::vast::hl::DoOp)</li> <li>hl.empty.decl (::vast::hl::EmptyDeclOp)</li> <li>hl.enum (::vast::hl::EnumDeclOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.enum.const (::vast::hl::EnumConstantOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.enumref (::vast::hl::EnumRefOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>hl.expr (::vast::hl::ExprOp)<ul> <li>Results:</li> </ul> </li> <li>hl.fadd (::vast::hl::AddFOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.fcmp (::vast::hl::FCmpOp)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.fdiv (::vast::hl::DivFOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.field (::vast::hl::FieldDeclOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.fmul (::vast::hl::MulFOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.for (::vast::hl::ForOp)</li> <li>hl.frem (::vast::hl::RemFOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.fsub (::vast::hl::SubFOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.func (::vast::hl::FuncOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.funcref (::vast::hl::FuncRefOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>hl.globref (::vast::hl::GlobalRefOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>hl.gnu.extension (::vast::hl::ExtensionOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.goto (::vast::hl::GotoStmt)<ul> <li>Operands:</li> </ul> </li> <li>hl.if (::vast::hl::IfOp)</li> <li>hl.implicit_cast (::vast::hl::ImplicitCastOp)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.indirect_call (::vast::hl::IndirectCallOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.initlist (::vast::hl::InitListExpr)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.label (::vast::hl::LabelStmt)<ul> <li>Operands:</li> </ul> </li> <li>hl.label.decl (::vast::hl::LabelDeclOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>hl.labeladdr (::vast::hl::AddrLabelExpr)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.lnot (::vast::hl::LNotOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.member (::vast::hl::RecordMemberOp)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.minus (::vast::hl::MinusOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.mul (::vast::hl::MulIOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.not (::vast::hl::NotOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.plus (::vast::hl::PlusOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.post.dec (::vast::hl::PostDecOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.post.inc (::vast::hl::PostIncOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.pre.dec (::vast::hl::PreDecOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.pre.inc (::vast::hl::PreIncOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.predefined.expr (::vast::hl::PredefinedExpr)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.ref (::vast::hl::DeclRefOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.return (::vast::hl::ReturnOp)<ul> <li>Operands:</li> </ul> </li> <li>hl.sdiv (::vast::hl::DivSOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.sizeof.expr (::vast::hl::SizeOfExprOp)<ul> <li>Results:</li> </ul> </li> <li>hl.sizeof.type (::vast::hl::SizeOfTypeOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>hl.skip (::vast::hl::SkipStmt)</li> <li>hl.srem (::vast::hl::RemSOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.stmt.expr (::vast::hl::StmtExprOp)<ul> <li>Results:</li> </ul> </li> <li>hl.struct (::vast::hl::StructDeclOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.sub (::vast::hl::SubIOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.subscript (::vast::hl::SubscriptOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.switch (::vast::hl::SwitchOp)</li> <li>hl.this (::vast::hl::ThisOp)<ul> <li>Results:</li> </ul> </li> <li>hl.translation_unit (::vast::hl::TranslationUnitOp)</li> <li>hl.type (::vast::hl::TypeDeclOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.type.yield (::vast::hl::TypeYieldOp)<ul> <li>Operands:</li> </ul> </li> <li>hl.typedef (::vast::hl::TypeDefOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.typeof.expr (::vast::hl::TypeOfExprOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.typeof.type (::vast::hl::TypeOfTypeOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.udiv (::vast::hl::DivUOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.union (::vast::hl::UnionDeclOp)<ul> <li>Attributes:</li> </ul> </li> <li>hl.unreachable (::vast::hl::UnreachableOp)</li> <li>hl.urem (::vast::hl::RemUOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>hl.value.yield (::vast::hl::ValueYieldOp)<ul> <li>Operands:</li> </ul> </li> <li>hl.var (::vast::hl::VarDeclOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>hl.while (::vast::hl::WhileOp)</li> </ul> </li> <li>Attribute definition<ul> <li>AllocAlignAttr<ul> <li>Parameters:</li> </ul> </li> <li>AllocSizeAttr<ul> <li>Parameters:</li> </ul> </li> <li>AnnotationAttr<ul> <li>Parameters:</li> </ul> </li> <li>AsmLabelAttr<ul> <li>Parameters:</li> </ul> </li> <li>BuiltinAttr<ul> <li>Parameters:</li> </ul> </li> <li>CVQualifiersAttr<ul> <li>Parameters:</li> </ul> </li> <li>CVRQualifiersAttr<ul> <li>Parameters:</li> </ul> </li> <li>ConstAttr</li> <li>FormatAttr<ul> <li>Parameters:</li> </ul> </li> <li>LoaderUninitializedAttr</li> <li>ModeAttr<ul> <li>Parameters:</li> </ul> </li> <li>NoInstrumentFunctionAttr</li> <li>NoThrowAttr</li> <li>NonNullAttr</li> <li>PackedAttr</li> <li>PureAttr</li> <li>RestrictAttr</li> <li>SectionAttr<ul> <li>Parameters:</li> </ul> </li> <li>UCVQualifiersAttr<ul> <li>Parameters:</li> </ul> </li> <li>WarnUnusedResultAttr</li> </ul> </li> <li>Type definition<ul> <li>AdjustedType<ul> <li>Parameters:</li> </ul> </li> <li>ArrayType<ul> <li>Parameters:</li> </ul> </li> <li>AttributedType<ul> <li>Parameters:</li> </ul> </li> <li>BFloat16Type<ul> <li>Parameters:</li> </ul> </li> <li>BoolType<ul> <li>Parameters:</li> </ul> </li> <li>CharType<ul> <li>Parameters:</li> </ul> </li> <li>DecayedType<ul> <li>Parameters:</li> </ul> </li> <li>DoubleType<ul> <li>Parameters:</li> </ul> </li> <li>ElaboratedType<ul> <li>Parameters:</li> </ul> </li> <li>EnumType<ul> <li>Parameters:</li> </ul> </li> <li>Float128Type<ul> <li>Parameters:</li> </ul> </li> <li>FloatType<ul> <li>Parameters:</li> </ul> </li> <li>HalfType<ul> <li>Parameters:</li> </ul> </li> <li>Int128Type<ul> <li>Parameters:</li> </ul> </li> <li>IntType<ul> <li>Parameters:</li> </ul> </li> <li>LValueType<ul> <li>Parameters:</li> </ul> </li> <li>LabelType</li> <li>LongDoubleType<ul> <li>Parameters:</li> </ul> </li> <li>LongLongType<ul> <li>Parameters:</li> </ul> </li> <li>LongType<ul> <li>Parameters:</li> </ul> </li> <li>ParenType<ul> <li>Parameters:</li> </ul> </li> <li>PointerType<ul> <li>Parameters:</li> </ul> </li> <li>RValueType<ul> <li>Parameters:</li> </ul> </li> <li>RecordType<ul> <li>Parameters:</li> </ul> </li> <li>ReferenceType<ul> <li>Parameters:</li> </ul> </li> <li>ShortType<ul> <li>Parameters:</li> </ul> </li> <li>TypeOfExprType<ul> <li>Parameters:</li> </ul> </li> <li>TypeOfTypeType<ul> <li>Parameters:</li> </ul> </li> <li>TypedefType<ul> <li>Parameters:</li> </ul> </li> <li>VoidType<ul> <li>Parameters:</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"dialects/HighLevel/HighLevel/#operation-definition","title":"Operation definition","text":""},{"location":"dialects/HighLevel/HighLevel/#hlaccess-vasthlaccessspecifierop","title":"<code>hl.access</code> (::vast::hl::AccessSpecifierOp)","text":"<p>VAST C++ access specifier declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.access` attr-dict $spec\n</code></pre> <p>VAST C++ access specifier declaration</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>spec</code> ::vast::hl::AccessSpecifierAttr Access specifier"},{"location":"dialects/HighLevel/HighLevel/#hladd-vasthladdiop","title":"<code>hl.add</code> (::vast::hl::AddIOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.add` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results) <p>Traits: Commutative</p>"},{"location":"dialects/HighLevel/HighLevel/#operands","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hladdressof-vasthladdressof","title":"<code>hl.addressof</code> (::vast::hl::AddressOf)","text":"<p>VAST addressof operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.addressof` $value attr-dict `:` type($value) `-&gt;` type($result)\n</code></pre> <p>VAST addressof operation</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_1","title":"Operands:","text":"Operand Description <code>value</code> lvalue to any type"},{"location":"dialects/HighLevel/HighLevel/#results_1","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlalignofexpr-vasthlalignofexprop","title":"<code>hl.alignof.expr</code> (::vast::hl::AlignOfExprOp)","text":"<p>VAST expr alignof operator</p> <p>Syntax:</p> <pre><code>operation ::= `hl.alignof.expr` attr-dict `-&gt;` type($result) $expr\n</code></pre> <p>VAST expr alignof operator</p>"},{"location":"dialects/HighLevel/HighLevel/#results_2","title":"Results:","text":"Result Description <code>result</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlalignoftype-vasthlalignoftypeop","title":"<code>hl.alignof.type</code> (::vast::hl::AlignOfTypeOp)","text":"<p>VAST type alignof operator</p> <p>Syntax:</p> <pre><code>operation ::= `hl.alignof.type` $arg attr-dict `-&gt;` type($result)\n</code></pre> <p>VAST type alignof operator</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>arg</code> ::mlir::TypeAttr any type attribute"},{"location":"dialects/HighLevel/HighLevel/#results_3","title":"Results:","text":"Result Description <code>result</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlassign-vasthlassignop","title":"<code>hl.assign</code> (::vast::hl::AssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_2","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_4","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignadd-vasthladdiassignop","title":"<code>hl.assign.add</code> (::vast::hl::AddIAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.add` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_3","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_5","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinand-vasthlbinandassignop","title":"<code>hl.assign.bin.and</code> (::vast::hl::BinAndAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.bin.and` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_4","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_6","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinashr-vasthlbinashrassignop","title":"<code>hl.assign.bin.ashr</code> (::vast::hl::BinAShrAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.bin.ashr` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_5","title":"Operands:","text":"Operand Description <code>src</code> lvalue to integer like type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_7","title":"Results:","text":"Result Description <code>result</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinlshr-vasthlbinlshrassignop","title":"<code>hl.assign.bin.lshr</code> (::vast::hl::BinLShrAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.bin.lshr` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_6","title":"Operands:","text":"Operand Description <code>src</code> lvalue to integer like type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_8","title":"Results:","text":"Result Description <code>result</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinor-vasthlbinorassignop","title":"<code>hl.assign.bin.or</code> (::vast::hl::BinOrAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.bin.or` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_7","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_9","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinshl-vasthlbinshlassignop","title":"<code>hl.assign.bin.shl</code> (::vast::hl::BinShlAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.bin.shl` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_8","title":"Operands:","text":"Operand Description <code>src</code> lvalue to integer like type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_10","title":"Results:","text":"Result Description <code>result</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlassignbinxor-vasthlbinxorassignop","title":"<code>hl.assign.bin.xor</code> (::vast::hl::BinXorAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.bin.xor` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_9","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_11","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignfadd-vasthladdfassignop","title":"<code>hl.assign.fadd</code> (::vast::hl::AddFAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.fadd` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_10","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_12","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignfdiv-vasthldivfassignop","title":"<code>hl.assign.fdiv</code> (::vast::hl::DivFAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.fdiv` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_11","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_13","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignfmul-vasthlmulfassignop","title":"<code>hl.assign.fmul</code> (::vast::hl::MulFAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.fmul` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_12","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_14","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignfrem-vasthlremfassignop","title":"<code>hl.assign.frem</code> (::vast::hl::RemFAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.frem` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_13","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_15","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignfsub-vasthlsubfassignop","title":"<code>hl.assign.fsub</code> (::vast::hl::SubFAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.fsub` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_14","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_16","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignmul-vasthlmuliassignop","title":"<code>hl.assign.mul</code> (::vast::hl::MulIAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.mul` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_15","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_17","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignsdiv-vasthldivsassignop","title":"<code>hl.assign.sdiv</code> (::vast::hl::DivSAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.sdiv` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_16","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_18","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignsrem-vasthlremsassignop","title":"<code>hl.assign.srem</code> (::vast::hl::RemSAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.srem` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_17","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_19","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignsub-vasthlsubiassignop","title":"<code>hl.assign.sub</code> (::vast::hl::SubIAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.sub` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_18","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_20","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignudiv-vasthldivuassignop","title":"<code>hl.assign.udiv</code> (::vast::hl::DivUAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.udiv` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_19","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_21","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlassignurem-vasthlremuassignop","title":"<code>hl.assign.urem</code> (::vast::hl::RemUAssignOp)","text":"<p>VAST compound assign operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.assign.urem` $src `to` $dst attr-dict `:` type(operands) `-&gt;` type(results)\n</code></pre> <p>A compound assign operation represents an assignment operation joined with an arithmetic operation. It requires the same types for both source and destination arguments.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  src to dst : functional-type(operands, results) <p>It represents C compound assignment statement:</p> <p>dst = src; <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_20","title":"Operands:","text":"Operand Description <code>src</code> lvalue to any type <code>dst</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_22","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlbase-vasthlcxxbasespecifierop","title":"<code>hl.base</code> (::vast::hl::CxxBaseSpecifierOp)","text":"<p>VAST base class specifier</p> <p>Syntax:</p> <pre><code>operation ::= `hl.base` $type attr-dict $access (`virtual` $is_virtual^)?\n</code></pre> <p>VAST base class specifier Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>type</code> ::mlir::TypeAttr any type attribute <code>access</code> ::vast::hl::AccessSpecifierAttr Access specifier <code>is_virtual</code> ::mlir::UnitAttr unit attribute"},{"location":"dialects/HighLevel/HighLevel/#hlbinand-vasthlbinandop","title":"<code>hl.bin.and</code> (::vast::hl::BinAndOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.bin.and` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_21","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_23","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlbinashr-vasthlbinashrop","title":"<code>hl.bin.ashr</code> (::vast::hl::BinAShrOp)","text":"<p>VAST binary shift operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.bin.ashr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level binary shift operation. This operation takes two operands and returns one result.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_22","title":"Operands:","text":"Operand Description <code>lhs</code> integer like type <code>rhs</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#results_24","title":"Results:","text":"Result Description <code>result</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlbincomma-vasthlbincomma","title":"<code>hl.bin.comma</code> (::vast::hl::BinComma)","text":"<p>VAST binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.bin.comma` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#operands_23","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_25","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlbinland-vasthlbinlandop","title":"<code>hl.bin.land</code> (::vast::hl::BinLAndOp)","text":"<p>VAST logical binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.bin.land` $lhs`,` $rhs attr-dict `:` type(results)\n</code></pre> <p>High-level logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : type"},{"location":"dialects/HighLevel/HighLevel/#results_26","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlbinlor-vasthlbinlorop","title":"<code>hl.bin.lor</code> (::vast::hl::BinLOrOp)","text":"<p>VAST logical binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.bin.lor` $lhs`,` $rhs attr-dict `:` type(results)\n</code></pre> <p>High-level logical binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : type"},{"location":"dialects/HighLevel/HighLevel/#results_27","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlbinlshr-vasthlbinlshrop","title":"<code>hl.bin.lshr</code> (::vast::hl::BinLShrOp)","text":"<p>VAST binary shift operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.bin.lshr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level binary shift operation. This operation takes two operands and returns one result.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_24","title":"Operands:","text":"Operand Description <code>lhs</code> integer like type <code>rhs</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#results_28","title":"Results:","text":"Result Description <code>result</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlbinor-vasthlbinorop","title":"<code>hl.bin.or</code> (::vast::hl::BinOrOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.bin.or` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_25","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_29","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlbinshl-vasthlbinshlop","title":"<code>hl.bin.shl</code> (::vast::hl::BinShlOp)","text":"<p>VAST binary shift operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.bin.shl` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level binary shift operation. This operation takes two operands and returns one result.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_26","title":"Operands:","text":"Operand Description <code>lhs</code> integer like type <code>rhs</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#results_30","title":"Results:","text":"Result Description <code>result</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlbinxor-vasthlbinxorop","title":"<code>hl.bin.xor</code> (::vast::hl::BinXorOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.bin.xor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_27","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_31","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlbreak-vasthlbreakop","title":"<code>hl.break</code> (::vast::hl::BreakOp)","text":"<p>VAST break statement</p> <p>Syntax:</p> <pre><code>operation ::= `hl.break` attr-dict\n</code></pre> <p>VAST break statement Traits: NoRegionArguments, NoTerminator, soft_terminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#hlbuiltin_bitcast-vasthlbuiltinbitcastop","title":"<code>hl.builtin_bitcast</code> (::vast::hl::BuiltinBitCastOp)","text":"<p>VAST cast operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.builtin_bitcast` $value $kind attr-dict `:` type($value) `-&gt;` type($result)\n</code></pre> <p>VAST cast operation</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>kind</code> ::vast::hl::CastKindAttr cast kind"},{"location":"dialects/HighLevel/HighLevel/#operands_28","title":"Operands:","text":"Operand Description <code>value</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_32","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlcall-vasthlcallop","title":"<code>hl.call</code> (::vast::hl::CallOp)","text":"<p>VAST call operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.call` $callee `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results )\n</code></pre> <p>VAST call operation Interfaces: CallOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_4","title":"Attributes:","text":"Attribute MLIR Type Description <code>callee</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"dialects/HighLevel/HighLevel/#operands_29","title":"Operands:","text":"Operand Description <code>argOperands</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_33","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlcase-vasthlcaseop","title":"<code>hl.case</code> (::vast::hl::CaseOp)","text":"<p>VAST case statement</p> <p>Syntax:</p> <pre><code>operation ::= `hl.case` $lhs $body attr-dict\n</code></pre> <p>The operation represents a single case of a switch statement.</p> <p>The generic form of the operation is as follows:</p> <p>hl.case {   ... / lhs/check region /   hl.value.yield %val : !hl.type } {   ... / body region / }</p> <p>It represents a C statement of form <code>case lhs: body;</code>.</p> <p>Traits: NoRegionArguments, NoTerminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#hlclass-vasthlclassdeclop","title":"<code>hl.class</code> (::vast::hl::ClassDeclOp)","text":"<p>VAST C++ class declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.class` $name attr-dict `:` `bases` $bases $fields\n</code></pre> <p>VAST C++ class declaration Traits: NoTerminator</p> <p>Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_5","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute"},{"location":"dialects/HighLevel/HighLevel/#hlcmp-vasthlcmpop","title":"<code>hl.cmp</code> (::vast::hl::CmpOp)","text":"<p>VAST comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.cmp` $predicate $lhs `,` $rhs  attr-dict `:` type(operands) `-&gt;` type($result)\n</code></pre> <p>VAST comparison operation</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_6","title":"Attributes:","text":"Attribute MLIR Type Description <code>predicate</code> ::vast::hl::PredicateAttr comparison predicate"},{"location":"dialects/HighLevel/HighLevel/#operands_30","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_34","title":"Results:","text":"Result Description <code>result</code> bool or integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlcond-vasthlcondop","title":"<code>hl.cond</code> (::vast::hl::CondOp)","text":"<p>VAST conditional statement</p> <p>Syntax:</p> <pre><code>operation ::= `hl.cond` $condRegion `?` $thenRegion `:` $elseRegion attr-dict `:` type(results)\n</code></pre> <p>The operation takes builders of three regions -- condition, true branch and false branch. Builders, given the location, build a particular region.</p> <p>The generic form of the operation is as follows:</p> <p>hl.cond {   ... / condition region /   hl.cond.yield %cond : !hl.bool } ? {   ... / true region / } : {   ... / false region / }</p> <p>Traits: NoRegionArguments, NoTerminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#results_35","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlcondyield-vasthlcondyieldop","title":"<code>hl.cond.yield</code> (::vast::hl::CondYieldOp)","text":"<p>Condition yield operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.cond.yield` attr-dict $result `:` type($result)\n</code></pre> <p>A condition yield operation is used to terminate the region representing condition expression of control flow operations <code>IfOp</code>, <code>WhileOp</code>, <code>ForOp</code> and <code>DoOp</code>. It yields a boolean value for the conditional branch.</p> <p>The custom assembly form of the operation is as follows:</p> <p>hl.cond.yield result : BoolType</p> <p>Traits: HasParent, Terminator"},{"location":"dialects/HighLevel/HighLevel/#operands_31","title":"Operands:","text":"Operand Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlconst-vasthlconstantop","title":"<code>hl.const</code> (::vast::hl::ConstantOp)","text":"<p>VAST value constant</p> <p>Syntax:</p> <pre><code>operation ::= `hl.const` $value attr-dict\n</code></pre> <p>VAST value constant Traits: ConstantLike</p> <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_7","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> ::mlir::TypedAttr TypedAttr instance"},{"location":"dialects/HighLevel/HighLevel/#results_36","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlcontinue-vasthlcontinueop","title":"<code>hl.continue</code> (::vast::hl::ContinueOp)","text":"<p>VAST continue statement</p> <p>Syntax:</p> <pre><code>operation ::= `hl.continue` attr-dict\n</code></pre> <p>VAST continue statement Traits: NoRegionArguments, NoTerminator, soft_terminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#hlcstyle_cast-vasthlcstylecastop","title":"<code>hl.cstyle_cast</code> (::vast::hl::CStyleCastOp)","text":"<p>VAST cast operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.cstyle_cast` $value $kind attr-dict `:` type($value) `-&gt;` type($result)\n</code></pre> <p>VAST cast operation</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_8","title":"Attributes:","text":"Attribute MLIR Type Description <code>kind</code> ::vast::hl::CastKindAttr cast kind"},{"location":"dialects/HighLevel/HighLevel/#operands_32","title":"Operands:","text":"Operand Description <code>value</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_37","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlcxxstruct-vasthlcxxstructdeclop","title":"<code>hl.cxxstruct</code> (::vast::hl::CxxStructDeclOp)","text":"<p>VAST C++ struct declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.cxxstruct` $name attr-dict `:` `bases` $bases $fields\n</code></pre> <p>VAST C++ struct declaration Traits: NoTerminator</p> <p>Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_9","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute"},{"location":"dialects/HighLevel/HighLevel/#hldefault-vasthldefaultop","title":"<code>hl.default</code> (::vast::hl::DefaultOp)","text":"<p>VAST default statement</p> <p>Syntax:</p> <pre><code>operation ::= `hl.default` $body attr-dict\n</code></pre> <p>VAST default statement Traits: NoRegionArguments, NoTerminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#hlderef-vasthlderef","title":"<code>hl.deref</code> (::vast::hl::Deref)","text":"<p>VAST deref operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.deref` $addr attr-dict `:` type($addr) `-&gt;` type($result)\n</code></pre> <p>VAST deref operation</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_33","title":"Operands:","text":"Operand Description <code>addr</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_38","title":"Results:","text":"Result Description <code>result</code> lvalue to any type"},{"location":"dialects/HighLevel/HighLevel/#hldo-vasthldoop","title":"<code>hl.do</code> (::vast::hl::DoOp)","text":"<p>VAST do-while statement</p> <p>Syntax:</p> <pre><code>operation ::= `hl.do` $bodyRegion `while` $condRegion attr-dict\n</code></pre> <p>The operation represents a do-while statement.</p> <p>The generic form of the operation is as follows:</p> <p>hl.do {   ... / body region / } cond {   ... / cond region /   hl.cond.yield %cond : !hl.bool }</p> <p>Traits: NoRegionArguments, NoTerminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#hlemptydecl-vasthlemptydeclop","title":"<code>hl.empty.decl</code> (::vast::hl::EmptyDeclOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `hl.empty.decl` attr-dict\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#hlenum-vasthlenumdeclop","title":"<code>hl.enum</code> (::vast::hl::EnumDeclOp)","text":"<p>VAST enum declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.enum` $name attr-dict `:` ($type^ $constants)?\n</code></pre> <p>Enum declaration serves to declare region for enum constant declarations. It also defines an underlying type.</p> <p>Traits: NoTerminator</p> <p>Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_10","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute"},{"location":"dialects/HighLevel/HighLevel/#hlenumconst-vasthlenumconstantop","title":"<code>hl.enum.const</code> (::vast::hl::EnumConstantOp)","text":"<p>VAST enum constant declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.enum.const` $name `=` $value attr-dict (`init` $init^)?\n</code></pre> <p>Enumeration constant servers to link name to an enum value. It is required to be scoped in Enum operation. For example:</p> <pre><code>hl.enum.const \"F\" = 2 : !hl.int\n</code></pre> <p>A constant can have a constant expression initializer:</p> <pre><code>hl.enum.const \"G\" = #core.integer&lt;12&gt; : !hl.int init  {\n  %0 = hl.enumref \"F\" : !hl.int\n  %1 = hl.enumref \"C\" : !hl.int\n  %2 = hl.add %0, %1 : !hl.int\n  hl.value.yield %2 : !hl.int\n}\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#attributes_11","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute <code>value</code> ::mlir::TypedAttr TypedAttr instance"},{"location":"dialects/HighLevel/HighLevel/#hlenumref-vasthlenumrefop","title":"<code>hl.enumref</code> (::vast::hl::EnumRefOp)","text":"<p>VAST variable reference declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.enumref` $value attr-dict `:` type($result)\n</code></pre> <p>VAST variable reference declaration</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_12","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> ::mlir::StringAttr string attribute"},{"location":"dialects/HighLevel/HighLevel/#results_39","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlexpr-vasthlexprop","title":"<code>hl.expr</code> (::vast::hl::ExprOp)","text":"<p>VAST expression</p> <p>Syntax:</p> <pre><code>operation ::= `hl.expr` attr-dict `:` type($result) $subexpr\n</code></pre> <p>VAST expression Traits: SingleBlock</p>"},{"location":"dialects/HighLevel/HighLevel/#results_40","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlfadd-vasthladdfop","title":"<code>hl.fadd</code> (::vast::hl::AddFOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.fadd` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_34","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_41","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlfcmp-vasthlfcmpop","title":"<code>hl.fcmp</code> (::vast::hl::FCmpOp)","text":"<p>VAST flaoting point comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.fcmp` $predicate $lhs `,` $rhs  attr-dict `:` type(operands) `-&gt;` type($result)\n</code></pre> <p>VAST floating point comparison operation</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_13","title":"Attributes:","text":"Attribute MLIR Type Description <code>predicate</code> ::vast::hl::FPredicateAttr floating point comparison predicate"},{"location":"dialects/HighLevel/HighLevel/#operands_35","title":"Operands:","text":"Operand Description <code>lhs</code> float like type <code>rhs</code> float like type"},{"location":"dialects/HighLevel/HighLevel/#results_42","title":"Results:","text":"Result Description <code>result</code> bool or integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlfdiv-vasthldivfop","title":"<code>hl.fdiv</code> (::vast::hl::DivFOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.fdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_36","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_43","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlfield-vasthlfielddeclop","title":"<code>hl.field</code> (::vast::hl::FieldDeclOp)","text":"<p>VAST record field declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.field` $name attr-dict (`bw` $bits^)? `:` $type\n</code></pre> <p>VAST record field declaration Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_14","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute <code>bits</code> ::mlir::IntegerAttr 32-bit signless integer attribute"},{"location":"dialects/HighLevel/HighLevel/#hlfmul-vasthlmulfop","title":"<code>hl.fmul</code> (::vast::hl::MulFOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.fmul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_37","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_44","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlfor-vasthlforop","title":"<code>hl.for</code> (::vast::hl::ForOp)","text":"<p>VAST for statement</p> <p>Syntax:</p> <pre><code>operation ::= `hl.for` $condRegion `incr` $incrRegion attr-dict `do` $bodyRegion\n</code></pre> <p>Operation represents a for-loop statement.</p> <p>The generic form of the operation is as follows:</p> <p>hl.for {   ... / cond region /   hl.cond.yield %cond : !hl.bool } incr {   ... / increment/update region / } do {   ... / body region / }</p> <p>Traits: NoRegionArguments, NoTerminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#hlfrem-vasthlremfop","title":"<code>hl.frem</code> (::vast::hl::RemFOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.frem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_38","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_45","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlfsub-vasthlsubfop","title":"<code>hl.fsub</code> (::vast::hl::SubFOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.fsub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_39","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_46","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlfunc-vasthlfuncop","title":"<code>hl.func</code> (::vast::hl::FuncOp)","text":"<p>VAST function template</p> <p>Syntax:</p> <pre><code>operation ::= `hl.func` $sym_name custom&lt; FunctionSignatureAndBody &gt;($function_type, attr-dict, $body)\n</code></pre> <p>Inspired by <code>cir::FuncOp</code> and <code>mlir::func::FuncOp</code>:</p> <p>Operations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are <code>IsolatedFromAbove</code>. All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body.</p> <p>The function linkage information is specified by <code>linkage</code>, as defined by <code>GlobalLinkageKind</code> attribute.</p> <p>Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator</p> <p>Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_15","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_name</code> ::mlir::StringAttr string attribute <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>linkage</code> ::vast::core::GlobalLinkageKindAttr global linkage kind <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"dialects/HighLevel/HighLevel/#hlfuncref-vasthlfuncrefop","title":"<code>hl.funcref</code> (::vast::hl::FuncRefOp)","text":"<p>VAST function reference declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.funcref` $function attr-dict `:` type($result)\n</code></pre> <p>VAST function reference declaration</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_16","title":"Attributes:","text":"Attribute MLIR Type Description <code>function</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"dialects/HighLevel/HighLevel/#results_47","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlglobref-vasthlglobalrefop","title":"<code>hl.globref</code> (::vast::hl::GlobalRefOp)","text":"<p>VAST global variable reference declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.globref` $global attr-dict `:` type($result)\n</code></pre> <p>VAST global variable reference declaration</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_17","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> ::mlir::StringAttr string attribute"},{"location":"dialects/HighLevel/HighLevel/#results_48","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlgnuextension-vasthlextensionop","title":"<code>hl.gnu.extension</code> (::vast::hl::ExtensionOp)","text":"<p>VAST extension (__extension__) keyword</p> <p>Syntax:</p> <pre><code>operation ::= `hl.gnu.extension` $value attr-dict `:` type($value) `-&gt;` type($result)\n</code></pre> <p>VAST op corresponding to GNU extension keyword.</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_40","title":"Operands:","text":"Operand Description <code>value</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_49","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlgoto-vasthlgotostmt","title":"<code>hl.goto</code> (::vast::hl::GotoStmt)","text":"<p>Syntax:</p> <pre><code>operation ::= `hl.goto` $label attr-dict\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#operands_41","title":"Operands:","text":"Operand Description <code>label</code>"},{"location":"dialects/HighLevel/HighLevel/#hlif-vasthlifop","title":"<code>hl.if</code> (::vast::hl::IfOp)","text":"<p>VAST if statement</p> <p>The operation takes builders of two mandatory regions -- condition and then region -- and one builder optional region representing else block of C if statement. Builders, given the location, build a particular region.</p> <p>The generic form of the operation is as follows:</p> <p>hl.if {   ... / condition region /   hl.cond.yield %cond : !hl.bool } then {   ... / then region / } else {   ... / else region / }</p> <p>Traits: NoRegionArguments, NoTerminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#hlimplicit_cast-vasthlimplicitcastop","title":"<code>hl.implicit_cast</code> (::vast::hl::ImplicitCastOp)","text":"<p>VAST cast operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.implicit_cast` $value $kind attr-dict `:` type($value) `-&gt;` type($result)\n</code></pre> <p>VAST cast operation</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_18","title":"Attributes:","text":"Attribute MLIR Type Description <code>kind</code> ::vast::hl::CastKindAttr cast kind"},{"location":"dialects/HighLevel/HighLevel/#operands_42","title":"Operands:","text":"Operand Description <code>value</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_50","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlindirect_call-vasthlindirectcallop","title":"<code>hl.indirect_call</code> (::vast::hl::IndirectCallOp)","text":"<p>VAST call operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.indirect_call` $callee `:` type($callee)  `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results )\n</code></pre> <p>VAST call operation Interfaces: CallOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_43","title":"Operands:","text":"Operand Description <code>callee</code> any type <code>argOperands</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_51","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlinitlist-vasthlinitlistexpr","title":"<code>hl.initlist</code> (::vast::hl::InitListExpr)","text":"<p>VAST initializer list expression</p> <p>Syntax:</p> <pre><code>operation ::= `hl.initlist` $elements attr-dict `:` functional-type($elements, results)\n</code></pre> <p>VAST initializer list expression</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_44","title":"Operands:","text":"Operand Description <code>elements</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_52","title":"Results:","text":"Result Description \u00abunnamed\u00bb any type"},{"location":"dialects/HighLevel/HighLevel/#hllabel-vasthllabelstmt","title":"<code>hl.label</code> (::vast::hl::LabelStmt)","text":"<p>VAST control flow operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.label` $label $body attr-dict\n</code></pre> <p>VAST control flow operation Traits: NoRegionArguments, NoTerminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_45","title":"Operands:","text":"Operand Description <code>label</code>"},{"location":"dialects/HighLevel/HighLevel/#hllabeldecl-vasthllabeldeclop","title":"<code>hl.label.decl</code> (::vast::hl::LabelDeclOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `hl.label.decl` $name attr-dict `:` type($result)\n</code></pre> <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_19","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute"},{"location":"dialects/HighLevel/HighLevel/#results_53","title":"Results:","text":"Result Description <code>result</code>"},{"location":"dialects/HighLevel/HighLevel/#hllabeladdr-vasthladdrlabelexpr","title":"<code>hl.labeladdr</code> (::vast::hl::AddrLabelExpr)","text":"<p>VAST address of label extension</p> <p>Syntax:</p> <pre><code>operation ::= `hl.labeladdr` $label attr-dict `:` type($result)\n</code></pre> <p>VAST address of label extension</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_46","title":"Operands:","text":"Operand Description <code>label</code>"},{"location":"dialects/HighLevel/HighLevel/#results_54","title":"Results:","text":"Result Description <code>result</code> lvalue to pointer like type"},{"location":"dialects/HighLevel/HighLevel/#hllnot-vasthllnotop","title":"<code>hl.lnot</code> (::vast::hl::LNotOp)","text":"<p>VAST unary logical operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.lnot` $arg attr-dict `:` type($arg) `-&gt;` type($res)\n</code></pre> <p>High-level unary logical operation assures that result has the right type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %arg : type -&gt; ret_type"},{"location":"dialects/HighLevel/HighLevel/#operands_47","title":"Operands:","text":"Operand Description <code>arg</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_55","title":"Results:","text":"Result Description <code>res</code> bool or integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlmember-vasthlrecordmemberop","title":"<code>hl.member</code> (::vast::hl::RecordMemberOp)","text":"<p>VAST record element access operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.member` $record `at` $name attr-dict `:` type($record) `-&gt;` type($element)\n</code></pre> <p>VAST record element access operation</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_20","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute"},{"location":"dialects/HighLevel/HighLevel/#operands_48","title":"Operands:","text":"Operand Description <code>record</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_56","title":"Results:","text":"Result Description <code>element</code> lvalue to any type"},{"location":"dialects/HighLevel/HighLevel/#hlminus-vasthlminusop","title":"<code>hl.minus</code> (::vast::hl::MinusOp)","text":"<p>VAST unary type preserving operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.minus` $arg attr-dict `:` type($result)\n</code></pre> <p>Type preserving high-level unary operation assures that argument and result has the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %arg : type <p>Traits: SameOperandsAndResultType</p> <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_49","title":"Operands:","text":"Operand Description <code>arg</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_57","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlmul-vasthlmuliop","title":"<code>hl.mul</code> (::vast::hl::MulIOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.mul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results) <p>Traits: Commutative</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_50","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_58","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlnot-vasthlnotop","title":"<code>hl.not</code> (::vast::hl::NotOp)","text":"<p>VAST unary type preserving operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.not` $arg attr-dict `:` type($result)\n</code></pre> <p>Type preserving high-level unary operation assures that argument and result has the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %arg : type <p>Traits: SameOperandsAndResultType</p> <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_51","title":"Operands:","text":"Operand Description <code>arg</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_59","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlplus-vasthlplusop","title":"<code>hl.plus</code> (::vast::hl::PlusOp)","text":"<p>VAST unary type preserving operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.plus` $arg attr-dict `:` type($result)\n</code></pre> <p>Type preserving high-level unary operation assures that argument and result has the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %arg : type <p>Traits: SameOperandsAndResultType</p> <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_52","title":"Operands:","text":"Operand Description <code>arg</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_60","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlpostdec-vasthlpostdecop","title":"<code>hl.post.dec</code> (::vast::hl::PostDecOp)","text":"<p>VAST unary inplace operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.post.dec` $arg attr-dict `:` type($arg) `-&gt;` type($result)\n</code></pre> <p>Inplace high-level unary operation changes its single argument in place. It does not produce a new value.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %arg : type <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_53","title":"Operands:","text":"Operand Description <code>arg</code> lvalue to any type"},{"location":"dialects/HighLevel/HighLevel/#results_61","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlpostinc-vasthlpostincop","title":"<code>hl.post.inc</code> (::vast::hl::PostIncOp)","text":"<p>VAST unary inplace operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.post.inc` $arg attr-dict `:` type($arg) `-&gt;` type($result)\n</code></pre> <p>Inplace high-level unary operation changes its single argument in place. It does not produce a new value.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %arg : type <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_54","title":"Operands:","text":"Operand Description <code>arg</code> lvalue to any type"},{"location":"dialects/HighLevel/HighLevel/#results_62","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlpredec-vasthlpredecop","title":"<code>hl.pre.dec</code> (::vast::hl::PreDecOp)","text":"<p>VAST unary inplace operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.pre.dec` $arg attr-dict `:` type($arg) `-&gt;` type($result)\n</code></pre> <p>Inplace high-level unary operation changes its single argument in place. It does not produce a new value.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %arg : type <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_55","title":"Operands:","text":"Operand Description <code>arg</code> lvalue to any type"},{"location":"dialects/HighLevel/HighLevel/#results_63","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlpreinc-vasthlpreincop","title":"<code>hl.pre.inc</code> (::vast::hl::PreIncOp)","text":"<p>VAST unary inplace operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.pre.inc` $arg attr-dict `:` type($arg) `-&gt;` type($result)\n</code></pre> <p>Inplace high-level unary operation changes its single argument in place. It does not produce a new value.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %arg : type <p>Interfaces: InferTypeOpInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_56","title":"Operands:","text":"Operand Description <code>arg</code> lvalue to any type"},{"location":"dialects/HighLevel/HighLevel/#results_64","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlpredefinedexpr-vasthlpredefinedexpr","title":"<code>hl.predefined.expr</code> (::vast::hl::PredefinedExpr)","text":"<p>VAT predefined expr ( such as __func__ )</p> <p>Syntax:</p> <pre><code>operation ::= `hl.predefined.expr` $value $kind attr-dict `:` type($value) `-&gt;` type($result)\n</code></pre> <p>VAT predefined expr ( such as func )</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_21","title":"Attributes:","text":"Attribute MLIR Type Description <code>kind</code> ::vast::hl::IdentKindAttr ident kind"},{"location":"dialects/HighLevel/HighLevel/#operands_57","title":"Operands:","text":"Operand Description <code>value</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_65","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlref-vasthldeclrefop","title":"<code>hl.ref</code> (::vast::hl::DeclRefOp)","text":"<p>VAST variable reference declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.ref` $decl attr-dict `:` functional-type(operands, results)\n</code></pre> <p>VAST variable reference declaration</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_58","title":"Operands:","text":"Operand Description <code>decl</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_66","title":"Results:","text":"Result Description <code>result</code> lvalue to any type"},{"location":"dialects/HighLevel/HighLevel/#hlreturn-vasthlreturnop","title":"<code>hl.return</code> (::vast::hl::ReturnOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `hl.return` ($result^ `:` type($result))? attr-dict\n</code></pre> <p>Traits: return_trait, soft_terminator</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_59","title":"Operands:","text":"Operand Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlsdiv-vasthldivsop","title":"<code>hl.sdiv</code> (::vast::hl::DivSOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.sdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_60","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_67","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlsizeofexpr-vasthlsizeofexprop","title":"<code>hl.sizeof.expr</code> (::vast::hl::SizeOfExprOp)","text":"<p>VAST expr sizeof operator</p> <p>Syntax:</p> <pre><code>operation ::= `hl.sizeof.expr` attr-dict `-&gt;` type($result) $expr\n</code></pre> <p>VAST expr sizeof operator</p>"},{"location":"dialects/HighLevel/HighLevel/#results_68","title":"Results:","text":"Result Description <code>result</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlsizeoftype-vasthlsizeoftypeop","title":"<code>hl.sizeof.type</code> (::vast::hl::SizeOfTypeOp)","text":"<p>VAST type sizeof operator</p> <p>Syntax:</p> <pre><code>operation ::= `hl.sizeof.type` $arg attr-dict `-&gt;` type($result)\n</code></pre> <p>VAST type sizeof operator</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_22","title":"Attributes:","text":"Attribute MLIR Type Description <code>arg</code> ::mlir::TypeAttr any type attribute"},{"location":"dialects/HighLevel/HighLevel/#results_69","title":"Results:","text":"Result Description <code>result</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#hlskip-vasthlskipstmt","title":"<code>hl.skip</code> (::vast::hl::SkipStmt)","text":"<p>VAST skip statement</p> <p>Syntax:</p> <pre><code>operation ::= `hl.skip` attr-dict\n</code></pre> <p>VAST skip statement</p>"},{"location":"dialects/HighLevel/HighLevel/#hlsrem-vasthlremsop","title":"<code>hl.srem</code> (::vast::hl::RemSOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.srem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_61","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_70","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlstmtexpr-vasthlstmtexprop","title":"<code>hl.stmt.expr</code> (::vast::hl::StmtExprOp)","text":"<p>VAST statement expression</p> <p>Syntax:</p> <pre><code>operation ::= `hl.stmt.expr` attr-dict `:` type($result) $substmt\n</code></pre> <p>VAST statement expression Traits: SingleBlock</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#results_71","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlstruct-vasthlstructdeclop","title":"<code>hl.struct</code> (::vast::hl::StructDeclOp)","text":"<p>VAST struct declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.struct` $name attr-dict `:` $fields\n</code></pre> <p>VAST struct declaration Traits: NoTerminator</p> <p>Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_23","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute"},{"location":"dialects/HighLevel/HighLevel/#hlsub-vasthlsubiop","title":"<code>hl.sub</code> (::vast::hl::SubIOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.sub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_62","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_72","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlsubscript-vasthlsubscriptop","title":"<code>hl.subscript</code> (::vast::hl::SubscriptOp)","text":"<p>VAST array subscript operator</p> <p>Syntax:</p> <pre><code>operation ::= `hl.subscript` $array `at` ` ` `[` $index `:` type($index) `]` attr-dict\n              `:` type($array) `-&gt;` type($result)\n</code></pre> <p>VAST array subscript operator</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_63","title":"Operands:","text":"Operand Description <code>array</code> lvalue to subscriptable type <code>index</code> integer like type"},{"location":"dialects/HighLevel/HighLevel/#results_73","title":"Results:","text":"Result Description <code>result</code> lvalue to any type"},{"location":"dialects/HighLevel/HighLevel/#hlswitch-vasthlswitchop","title":"<code>hl.switch</code> (::vast::hl::SwitchOp)","text":"<p>VAST switch statement</p> <p>Syntax:</p> <pre><code>operation ::= `hl.switch` $condRegion `cases` $cases attr-dict\n</code></pre> <p>The operation represents a switch statement.</p> <p>The generic form of the operation is as follows:</p> <p>hl.switch {   ... / cond region /   hl.value.yield %val : !hl.type } cases {   ... / casesregion / }</p> <p>Traits: NoRegionArguments, NoTerminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#hlthis-vasthlthisop","title":"<code>hl.this</code> (::vast::hl::ThisOp)","text":"<p>VAST this operator</p> <p>Syntax:</p> <pre><code>operation ::= `hl.this` attr-dict `:` type($result)\n</code></pre> <p>VAST this operator</p>"},{"location":"dialects/HighLevel/HighLevel/#results_74","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hltranslation_unit-vasthltranslationunitop","title":"<code>hl.translation_unit</code> (::vast::hl::TranslationUnitOp)","text":"<p>VAST translation unit</p> <p>Syntax:</p> <pre><code>operation ::= `hl.translation_unit` $body attr-dict\n</code></pre> <p>VAST tranaslation unit Traits: IsolatedFromAbove, NoTerminator, SymbolTable</p>"},{"location":"dialects/HighLevel/HighLevel/#hltype-vasthltypedeclop","title":"<code>hl.type</code> (::vast::hl::TypeDeclOp)","text":"<p>VAST type declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.type` $name attr-dict\n</code></pre> <p>VAST type declaration Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_24","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute"},{"location":"dialects/HighLevel/HighLevel/#hltypeyield-vasthltypeyieldop","title":"<code>hl.type.yield</code> (::vast::hl::TypeYieldOp)","text":"<p>Type yield operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.type.yield` attr-dict $result `:` type($result)\n</code></pre> <p>A type yield operation is used to terminate the underlying expression region of a typeof(expr) statement.</p> <p>The custom assembly form of the operation is as follows:</p> <p>hl.type.yield result : type</p> <p>Traits: Terminator</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_64","title":"Operands:","text":"Operand Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hltypedef-vasthltypedefop","title":"<code>hl.typedef</code> (::vast::hl::TypeDefOp)","text":"<p>VAST typedef operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.typedef` $name attr-dict `:` $type\n</code></pre> <p>Typedef operation servers to declare named types. It creates a new type symbol in the current scope to be referenced as NamedType later.</p> <p>Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_25","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute"},{"location":"dialects/HighLevel/HighLevel/#hltypeofexpr-vasthltypeofexprop","title":"<code>hl.typeof.expr</code> (::vast::hl::TypeOfExprOp)","text":"<p>VAST typeof(expr) operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.typeof.expr` $name $expr `:` $type attr-dict\n</code></pre> <p>The Typeof operation serves to declare a type using type introspection. It evaluates its underlying expression, creates a new type symbol in the current scope, assigns it to the type of the underlying expression, and returns the type symbol to be referenced later</p> <p>Traits: SingleBlock</p> <p>Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_26","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute"},{"location":"dialects/HighLevel/HighLevel/#hltypeoftype-vasthltypeoftypeop","title":"<code>hl.typeof.type</code> (::vast::hl::TypeOfTypeOp)","text":"<p>VAST typeof(type) operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.typeof.type` attr-dict `:` $type\n</code></pre> <p>Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_27","title":"Attributes:","text":"Attribute MLIR Type Description <code>type</code> ::mlir::TypeAttr any type attribute"},{"location":"dialects/HighLevel/HighLevel/#hludiv-vasthldivuop","title":"<code>hl.udiv</code> (::vast::hl::DivUOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.udiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_65","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_75","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlunion-vasthluniondeclop","title":"<code>hl.union</code> (::vast::hl::UnionDeclOp)","text":"<p>VAST record declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.union` $name attr-dict `:` $fields\n</code></pre> <p>VAST record declaration Traits: NoTerminator</p> <p>Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_28","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute"},{"location":"dialects/HighLevel/HighLevel/#hlunreachable-vasthlunreachableop","title":"<code>hl.unreachable</code> (::vast::hl::UnreachableOp)","text":"<p>VAST unreachable operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.unreachable` attr-dict\n</code></pre> <p>VAST unreachable operation Traits: Terminator</p>"},{"location":"dialects/HighLevel/HighLevel/#hlurem-vasthlremuop","title":"<code>hl.urem</code> (::vast::hl::RemUOp)","text":"<p>VAST arithmetic binary operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.urem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre> <p>High-level arithmetic binary operation. This operation takes two operands and returns one result, each of these is required to be of the same type.</p> <p>The custom assembly form of the operation is as follows:</p> <p>%result =  %lhs, %rhs  : functional-type(operands, results)"},{"location":"dialects/HighLevel/HighLevel/#operands_66","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"dialects/HighLevel/HighLevel/#results_76","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlvalueyield-vasthlvalueyieldop","title":"<code>hl.value.yield</code> (::vast::hl::ValueYieldOp)","text":"<p>Value yield operation</p> <p>Syntax:</p> <pre><code>operation ::= `hl.value.yield` attr-dict $result `:` type($result)\n</code></pre> <p>A value yield operation is used to terminate the case region of a switch statement. The yielded value triggers the parent case statement region.</p> <p>The custom assembly form of the operation is as follows:</p> <p>hl.value.yield result : type</p> <p>Traits: Terminator</p>"},{"location":"dialects/HighLevel/HighLevel/#operands_67","title":"Operands:","text":"Operand Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlvar-vasthlvardeclop","title":"<code>hl.var</code> (::vast::hl::VarDeclOp)","text":"<p>VAST variable declaration</p> <p>Syntax:</p> <pre><code>operation ::= `hl.var` $name attr-dict ($storageClass^)? ($threadStorageClass^)? `:` type($result)\n              (`=` $initializer^)?\n              (`allocation_size` $allocation_size^)?\n</code></pre> <p>VAST variable declaration Interfaces: VastSymbol</p>"},{"location":"dialects/HighLevel/HighLevel/#attributes_29","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute <code>storageClass</code> ::vast::hl::StorageClassAttr storage class <code>threadStorageClass</code> ::vast::hl::TSClassAttr thread storage class"},{"location":"dialects/HighLevel/HighLevel/#results_77","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/HighLevel/HighLevel/#hlwhile-vasthlwhileop","title":"<code>hl.while</code> (::vast::hl::WhileOp)","text":"<p>VAST while statement</p> <p>Syntax:</p> <pre><code>operation ::= `hl.while` $condRegion `do` $bodyRegion attr-dict\n</code></pre> <p>The operation takes builders of two mandatory regions -- condition and body region. Builders, given the location, build a particular region.</p> <p>The generic form of the operation is as follows:</p> <p>hl.while {   ... / condition region /   hl.cond.yield %cond : !hl.bool } do {   ... / body region / }</p> <p>Traits: NoRegionArguments, NoTerminator</p> <p>Interfaces: RegionKindInterface</p>"},{"location":"dialects/HighLevel/HighLevel/#attribute-definition","title":"Attribute definition","text":""},{"location":"dialects/HighLevel/HighLevel/#allocalignattr","title":"AllocAlignAttr","text":"<p>Syntax:</p> <pre><code>#hl.alloc_align&lt;\n  int   # alignment\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters","title":"Parameters:","text":"Parameter C++ type Description alignment <code>int</code>"},{"location":"dialects/HighLevel/HighLevel/#allocsizeattr","title":"AllocSizeAttr","text":"<p>Syntax:</p> <pre><code>#hl.alloc_size&lt;\n  int,   # size_arg_pos\n  int   # num_arg_pos\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_1","title":"Parameters:","text":"Parameter C++ type Description size_arg_pos <code>int</code> num_arg_pos <code>int</code>"},{"location":"dialects/HighLevel/HighLevel/#annotationattr","title":"AnnotationAttr","text":"<p>Syntax:</p> <pre><code>#hl.annotation&lt;\n  ::mlir::StringAttr   # name\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_2","title":"Parameters:","text":"Parameter C++ type Description name <code>::mlir::StringAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#asmlabelattr","title":"AsmLabelAttr","text":"<p>Syntax:</p> <pre><code>#hl.asm&lt;\n  ::mlir::StringAttr,   # label\n  bool   # isLiteral\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_3","title":"Parameters:","text":"Parameter C++ type Description label <code>::mlir::StringAttr</code> isLiteral <code>bool</code>"},{"location":"dialects/HighLevel/HighLevel/#builtinattr","title":"BuiltinAttr","text":"<p>Syntax:</p> <pre><code>#hl.builtin&lt;\n  unsigned   # ID\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_4","title":"Parameters:","text":"Parameter C++ type Description ID <code>unsigned</code>"},{"location":"dialects/HighLevel/HighLevel/#cvqualifiersattr","title":"CVQualifiersAttr","text":"<p>Syntax:</p> <pre><code>#hl.quals&lt;\n  bool,   # is_const\n  bool   # is_volatile\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_5","title":"Parameters:","text":"Parameter C++ type Description is_const <code>bool</code> const qualifier is_volatile <code>bool</code> volatile qualifier"},{"location":"dialects/HighLevel/HighLevel/#cvrqualifiersattr","title":"CVRQualifiersAttr","text":"<p>Syntax:</p> <pre><code>#hl.quals&lt;\n  bool,   # is_const\n  bool,   # is_volatile\n  bool   # is_restrict\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_6","title":"Parameters:","text":"Parameter C++ type Description is_const <code>bool</code> const qualifier is_volatile <code>bool</code> volatile qualifier is_restrict <code>bool</code> restrict qualifier"},{"location":"dialects/HighLevel/HighLevel/#constattr","title":"ConstAttr","text":"<p>Syntax: <code>#hl.const</code></p>"},{"location":"dialects/HighLevel/HighLevel/#formatattr","title":"FormatAttr","text":"<p>Syntax:</p> <pre><code>#hl.format&lt;\n  ::mlir::StringAttr   # name\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_7","title":"Parameters:","text":"Parameter C++ type Description name <code>::mlir::StringAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#loaderuninitializedattr","title":"LoaderUninitializedAttr","text":"<p>Syntax: <code>#hl.loader_uninitialized</code></p>"},{"location":"dialects/HighLevel/HighLevel/#modeattr","title":"ModeAttr","text":"<p>Syntax:</p> <pre><code>#hl.mode&lt;\n  ::mlir::StringAttr   # mode\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_8","title":"Parameters:","text":"Parameter C++ type Description mode <code>::mlir::StringAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#noinstrumentfunctionattr","title":"NoInstrumentFunctionAttr","text":"<p>Syntax: <code>#hl.no_instrument_function</code></p>"},{"location":"dialects/HighLevel/HighLevel/#nothrowattr","title":"NoThrowAttr","text":"<p>Syntax: <code>#hl.nothrow</code></p>"},{"location":"dialects/HighLevel/HighLevel/#nonnullattr","title":"NonNullAttr","text":"<p>Syntax: <code>#hl.nonnull</code></p>"},{"location":"dialects/HighLevel/HighLevel/#packedattr","title":"PackedAttr","text":"<p>Syntax: <code>#hl.packed</code></p>"},{"location":"dialects/HighLevel/HighLevel/#pureattr","title":"PureAttr","text":"<p>Syntax: <code>#hl.pure</code></p>"},{"location":"dialects/HighLevel/HighLevel/#restrictattr","title":"RestrictAttr","text":"<p>Syntax: <code>#hl.restrict</code></p>"},{"location":"dialects/HighLevel/HighLevel/#sectionattr","title":"SectionAttr","text":"<p>Syntax:</p> <pre><code>#hl.section&lt;\n  ::mlir::StringAttr   # name\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_9","title":"Parameters:","text":"Parameter C++ type Description name <code>::mlir::StringAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#ucvqualifiersattr","title":"UCVQualifiersAttr","text":"<p>Syntax:</p> <pre><code>#hl.quals&lt;\n  bool,   # is_unsigned\n  bool,   # is_const\n  bool   # is_volatile\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_10","title":"Parameters:","text":"Parameter C++ type Description is_unsigned <code>bool</code> unsigned qualifier is_const <code>bool</code> const qualifier is_volatile <code>bool</code> volatile qualifier"},{"location":"dialects/HighLevel/HighLevel/#warnunusedresultattr","title":"WarnUnusedResultAttr","text":"<p>Syntax: <code>#hl.warn_unused_result</code></p>"},{"location":"dialects/HighLevel/HighLevel/#type-definition","title":"Type definition","text":""},{"location":"dialects/HighLevel/HighLevel/#adjustedtype","title":"AdjustedType","text":"<p>Syntax:</p> <pre><code>!hl.adjusted&lt;\n  Type,   # original\n  Type   # adjusted\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_11","title":"Parameters:","text":"Parameter C++ type Description original <code>Type</code> adjusted <code>Type</code>"},{"location":"dialects/HighLevel/HighLevel/#arraytype","title":"ArrayType","text":"<p>Syntax:</p> <pre><code>!hl.array&lt;\n  SizeParam,   # size\n  Type,   # elementType\n  CVRQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_12","title":"Parameters:","text":"Parameter C++ type Description size <code>SizeParam</code> size parameter for arrays elementType <code>Type</code> quals <code>CVRQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#attributedtype","title":"AttributedType","text":"<p>Syntax:</p> <pre><code>!hl.attributed&lt;\n  Type   # elementType\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_13","title":"Parameters:","text":"Parameter C++ type Description elementType <code>Type</code>"},{"location":"dialects/HighLevel/HighLevel/#bfloat16type","title":"BFloat16Type","text":"<p>Syntax:</p> <pre><code>!hl.bfloat16&lt;\n  CVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_14","title":"Parameters:","text":"Parameter C++ type Description quals <code>CVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#booltype","title":"BoolType","text":"<p>Syntax:</p> <pre><code>!hl.bool&lt;\n  CVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_15","title":"Parameters:","text":"Parameter C++ type Description quals <code>CVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#chartype","title":"CharType","text":"<p>Syntax:</p> <pre><code>!hl.char&lt;\n  UCVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_16","title":"Parameters:","text":"Parameter C++ type Description quals <code>UCVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#decayedtype","title":"DecayedType","text":"<p>Syntax:</p> <pre><code>!hl.decayed&lt;\n  Type   # elementType\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_17","title":"Parameters:","text":"Parameter C++ type Description elementType <code>Type</code>"},{"location":"dialects/HighLevel/HighLevel/#doubletype","title":"DoubleType","text":"<p>Syntax:</p> <pre><code>!hl.double&lt;\n  CVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_18","title":"Parameters:","text":"Parameter C++ type Description quals <code>CVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#elaboratedtype","title":"ElaboratedType","text":"<p>Syntax:</p> <pre><code>!hl.elaborated&lt;\n  Type,   # elementType\n  CVRQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_19","title":"Parameters:","text":"Parameter C++ type Description elementType <code>Type</code> quals <code>CVRQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#enumtype","title":"EnumType","text":"<p>Syntax:</p> <pre><code>!hl.enum&lt;\n  ::llvm::StringRef,   # name\n  CVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_20","title":"Parameters:","text":"Parameter C++ type Description name <code>::llvm::StringRef</code> quals <code>CVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#float128type","title":"Float128Type","text":"<p>Syntax:</p> <pre><code>!hl.float128&lt;\n  CVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_21","title":"Parameters:","text":"Parameter C++ type Description quals <code>CVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#floattype","title":"FloatType","text":"<p>Syntax:</p> <pre><code>!hl.float&lt;\n  CVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_22","title":"Parameters:","text":"Parameter C++ type Description quals <code>CVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#halftype","title":"HalfType","text":"<p>Syntax:</p> <pre><code>!hl.half&lt;\n  CVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_23","title":"Parameters:","text":"Parameter C++ type Description quals <code>CVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#int128type","title":"Int128Type","text":"<p>Syntax:</p> <pre><code>!hl.int128&lt;\n  UCVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_24","title":"Parameters:","text":"Parameter C++ type Description quals <code>UCVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#inttype","title":"IntType","text":"<p>Syntax:</p> <pre><code>!hl.int&lt;\n  UCVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_25","title":"Parameters:","text":"Parameter C++ type Description quals <code>UCVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#lvaluetype","title":"LValueType","text":"<p>Syntax:</p> <pre><code>!hl.lvalue&lt;\n  Type   # elementType\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_26","title":"Parameters:","text":"Parameter C++ type Description elementType <code>Type</code>"},{"location":"dialects/HighLevel/HighLevel/#labeltype","title":"LabelType","text":"<p>Syntax: <code>!hl.label</code></p>"},{"location":"dialects/HighLevel/HighLevel/#longdoubletype","title":"LongDoubleType","text":"<p>Syntax:</p> <pre><code>!hl.longdouble&lt;\n  CVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_27","title":"Parameters:","text":"Parameter C++ type Description quals <code>CVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#longlongtype","title":"LongLongType","text":"<p>Syntax:</p> <pre><code>!hl.longlong&lt;\n  UCVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_28","title":"Parameters:","text":"Parameter C++ type Description quals <code>UCVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#longtype","title":"LongType","text":"<p>Syntax:</p> <pre><code>!hl.long&lt;\n  UCVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_29","title":"Parameters:","text":"Parameter C++ type Description quals <code>UCVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#parentype","title":"ParenType","text":"<p>Syntax:</p> <pre><code>!hl.paren&lt;\n  Type   # elementType\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_30","title":"Parameters:","text":"Parameter C++ type Description elementType <code>Type</code>"},{"location":"dialects/HighLevel/HighLevel/#pointertype","title":"PointerType","text":"<p>Syntax:</p> <pre><code>!hl.ptr&lt;\n  Type,   # elementType\n  CVRQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_31","title":"Parameters:","text":"Parameter C++ type Description elementType <code>Type</code> quals <code>CVRQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#rvaluetype","title":"RValueType","text":"<p>Syntax:</p> <pre><code>!hl.rvalue&lt;\n  Type   # elementType\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_32","title":"Parameters:","text":"Parameter C++ type Description elementType <code>Type</code>"},{"location":"dialects/HighLevel/HighLevel/#recordtype","title":"RecordType","text":"<p>Syntax:</p> <pre><code>!hl.record&lt;\n  ::llvm::StringRef,   # name\n  CVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_33","title":"Parameters:","text":"Parameter C++ type Description name <code>::llvm::StringRef</code> quals <code>CVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#referencetype","title":"ReferenceType","text":"<p>Syntax:</p> <pre><code>!hl.reference&lt;\n  Type   # elementType\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_34","title":"Parameters:","text":"Parameter C++ type Description elementType <code>Type</code>"},{"location":"dialects/HighLevel/HighLevel/#shorttype","title":"ShortType","text":"<p>Syntax:</p> <pre><code>!hl.short&lt;\n  UCVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_35","title":"Parameters:","text":"Parameter C++ type Description quals <code>UCVQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#typeofexprtype","title":"TypeOfExprType","text":"<p>Syntax:</p> <pre><code>!hl.typeof.expr&lt;\n  ::llvm::StringRef,   # name\n  CVRQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_36","title":"Parameters:","text":"Parameter C++ type Description name <code>::llvm::StringRef</code> quals <code>CVRQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#typeoftypetype","title":"TypeOfTypeType","text":"<p>Syntax:</p> <pre><code>!hl.typeof.type&lt;\n  Type,   # unmodifiedType\n  CVRQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_37","title":"Parameters:","text":"Parameter C++ type Description unmodifiedType <code>Type</code> quals <code>CVRQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#typedeftype","title":"TypedefType","text":"<p>Syntax:</p> <pre><code>!hl.typedef&lt;\n  ::llvm::StringRef,   # name\n  CVRQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_38","title":"Parameters:","text":"Parameter C++ type Description name <code>::llvm::StringRef</code> quals <code>CVRQualifiersAttr</code>"},{"location":"dialects/HighLevel/HighLevel/#voidtype","title":"VoidType","text":"<p>Syntax:</p> <pre><code>!hl.void&lt;\n  CVQualifiersAttr   # quals\n&gt;\n</code></pre>"},{"location":"dialects/HighLevel/HighLevel/#parameters_39","title":"Parameters:","text":"Parameter C++ type Description quals <code>CVQualifiersAttr</code>"},{"location":"dialects/LowLevel/LowLevel/","title":"Low Level","text":""},{"location":"dialects/LowLevel/LowLevel/#ll-dialect","title":"'ll' Dialect","text":"<p>A vast low-level dialect. This dialect serves as a bottom layer in VAST dialect tower. There should always exist a pass that lowers this dialect into LLVM Dialect.</p> <p>Work in progress - new operations are still being added and existing can be changed or removed.</p> <ul> <li>'ll' Dialect<ul> <li>Operation definition<ul> <li>ll.br (::vast::ll::Br)<ul> <li>Operands:</li> <li>Successors:</li> </ul> </li> <li>ll.concat (::vast::ll::Concat)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>ll.cond_br (::vast::ll::CondBr)<ul> <li>Operands:</li> <li>Successors:</li> </ul> </li> <li>ll.cond_scope_ret (::vast::ll::CondScopeRet)<ul> <li>Operands:</li> <li>Successors:</li> </ul> </li> <li>ll.extract (::vast::ll::Extract)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>ll.func (::vast::ll::FuncOp)<ul> <li>Attributes:</li> </ul> </li> <li>ll.gep (::vast::ll::StructGEPOp)<ul> <li>Attributes:</li> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>ll.initialize (::vast::ll::InitializeVar)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>ll.inline_scope (::vast::ll::InlineScope)</li> <li>ll.return (::vast::ll::ReturnOp)<ul> <li>Operands:</li> </ul> </li> <li>ll.scope (::vast::ll::Scope)</li> <li>ll.scope_recurse (::vast::ll::ScopeRecurse)</li> <li>ll.scope_ret (::vast::ll::ScopeRet)</li> <li>ll.uninitialized_var (::vast::ll::UninitializedVar)<ul> <li>Results:</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"dialects/LowLevel/LowLevel/#operation-definition","title":"Operation definition","text":""},{"location":"dialects/LowLevel/LowLevel/#llbr-vastllbr","title":"<code>ll.br</code> (::vast::ll::Br)","text":"<p>Direct branch.</p> <p>Syntax:</p> <pre><code>operation ::= `ll.br` $dest (`(` $operands^ `:` type($operands) `)`)? attr-dict\n</code></pre> <p>Direct branch Traits: Terminator</p> <p>Interfaces: BranchOpInterface</p>"},{"location":"dialects/LowLevel/LowLevel/#operands","title":"Operands:","text":"Operand Description <code>operands</code> any type"},{"location":"dialects/LowLevel/LowLevel/#successors","title":"Successors:","text":"Successor Description <code>dest</code> any successor"},{"location":"dialects/LowLevel/LowLevel/#llconcat-vastllconcat","title":"<code>ll.concat</code> (::vast::ll::Concat)","text":"<p>Concat integers together</p> <p>Syntax:</p> <pre><code>operation ::= `ll.concat` operands attr-dict `:` functional-type(operands, results)\n</code></pre> <p>Concat operands together, where first argument occupies lsb.</p>"},{"location":"dialects/LowLevel/LowLevel/#operands_1","title":"Operands:","text":"Operand Description <code>args</code> any type"},{"location":"dialects/LowLevel/LowLevel/#results","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/LowLevel/LowLevel/#llcond_br-vastllcondbr","title":"<code>ll.cond_br</code> (::vast::ll::CondBr)","text":"<p>Conditional branch.</p> <p>Syntax:</p> <pre><code>operation ::= `ll.cond_br` $cond `:` type($cond) `,`\n              $trueDest (`(` $trueOperands^ `:` type($trueOperands) `)`)? `,`\n              $falseDest (`(` $falseOperands^ `:` type($falseOperands) `)`)?\n              attr-dict\n</code></pre> <p>Direct branch Traits: AttrSizedOperandSegments, Terminator</p>"},{"location":"dialects/LowLevel/LowLevel/#operands_2","title":"Operands:","text":"Operand Description <code>cond</code> any type <code>trueOperands</code> any type <code>falseOperands</code> any type"},{"location":"dialects/LowLevel/LowLevel/#successors_1","title":"Successors:","text":"Successor Description <code>trueDest</code> any successor <code>falseDest</code> any successor"},{"location":"dialects/LowLevel/LowLevel/#llcond_scope_ret-vastllcondscoperet","title":"<code>ll.cond_scope_ret</code> (::vast::ll::CondScopeRet)","text":"<p>Terminator of scope if condition is met, otherwise branch.</p> <p>Syntax:</p> <pre><code>operation ::= `ll.cond_scope_ret` $cond `:` type($cond) `,`\n              $dest (`(` $dest_operands^ `:` type($dest_operands) `)`)? attr-dict\n</code></pre> <p>Terminate or branch. Traits: Terminator</p>"},{"location":"dialects/LowLevel/LowLevel/#operands_3","title":"Operands:","text":"Operand Description <code>cond</code> any type <code>dest_operands</code> any type"},{"location":"dialects/LowLevel/LowLevel/#successors_2","title":"Successors:","text":"Successor Description <code>dest</code> any successor"},{"location":"dialects/LowLevel/LowLevel/#llextract-vastllextract","title":"<code>ll.extract</code> (::vast::ll::Extract)","text":"<p>Extracts value</p> <p>Syntax:</p> <pre><code>operation ::= `ll.extract` operands attr-dict `:` functional-type(operands, results)\n</code></pre> <p><code>0</code> is lsb, <code>[inc, exc)</code></p>"},{"location":"dialects/LowLevel/LowLevel/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>from</code> ::mlir::TypedAttr TypedAttr instance <code>to</code> ::mlir::TypedAttr TypedAttr instance"},{"location":"dialects/LowLevel/LowLevel/#operands_4","title":"Operands:","text":"Operand Description <code>arg</code> any type"},{"location":"dialects/LowLevel/LowLevel/#results_1","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/LowLevel/LowLevel/#llfunc-vastllfuncop","title":"<code>ll.func</code> (::vast::ll::FuncOp)","text":"<p>VAST function template</p> <p>Syntax:</p> <pre><code>operation ::= `ll.func` $linkage $sym_name custom&lt; FunctionSignatureAndBody &gt;($function_type, attr-dict, $body)\n</code></pre> <p>Inspired by <code>cir::FuncOp</code> and <code>mlir::func::FuncOp</code>:</p> <p>Operations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are <code>IsolatedFromAbove</code>. All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body.</p> <p>The function linkage information is specified by <code>linkage</code>, as defined by <code>GlobalLinkageKind</code> attribute.</p> <p>Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator</p> <p>Interfaces: CallableOpInterface, FunctionOpInterface, RegionKindInterface, Symbol</p>"},{"location":"dialects/LowLevel/LowLevel/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_name</code> ::mlir::StringAttr string attribute <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>linkage</code> ::vast::core::GlobalLinkageKindAttr global linkage kind <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"dialects/LowLevel/LowLevel/#llgep-vastllstructgepop","title":"<code>ll.gep</code> (::vast::ll::StructGEPOp)","text":"<p>VAST struct gep  operation</p> <p>VAST struct gep operation</p>"},{"location":"dialects/LowLevel/LowLevel/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>idx</code> ::mlir::IntegerAttr 32-bit signless integer attribute <code>name</code> ::mlir::StringAttr string attribute"},{"location":"dialects/LowLevel/LowLevel/#operands_5","title":"Operands:","text":"Operand Description <code>record</code> any type"},{"location":"dialects/LowLevel/LowLevel/#results_2","title":"Results:","text":"Result Description <code>element</code> any type"},{"location":"dialects/LowLevel/LowLevel/#llinitialize-vastllinitializevar","title":"<code>ll.initialize</code> (::vast::ll::InitializeVar)","text":"<p>Initialize a variable.</p> <p>Syntax:</p> <pre><code>operation ::= `ll.initialize` operands attr-dict `:` functional-type(operands, results)\n</code></pre> <p>Initialize a variable - for now this operation is a direct lowering from hl.var initialization section. Later there will be need to discover how this ties to constructors.</p>"},{"location":"dialects/LowLevel/LowLevel/#operands_6","title":"Operands:","text":"Operand Description <code>var</code> any type <code>elements</code> any type"},{"location":"dialects/LowLevel/LowLevel/#results_3","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/LowLevel/LowLevel/#llinline_scope-vastllinlinescope","title":"<code>ll.inline_scope</code> (::vast::ll::InlineScope)","text":"<p>Scope, that forwards (cond)scope return up.</p> <p>Result of inlined if. Traits: NoRegionArguments</p>"},{"location":"dialects/LowLevel/LowLevel/#llreturn-vastllreturnop","title":"<code>ll.return</code> (::vast::ll::ReturnOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `ll.return` ($result^ `:` type($result))? attr-dict\n</code></pre> <p>Traits: Terminator, return_trait</p>"},{"location":"dialects/LowLevel/LowLevel/#operands_7","title":"Operands:","text":"Operand Description <code>result</code> any type"},{"location":"dialects/LowLevel/LowLevel/#llscope-vastllscope","title":"<code>ll.scope</code> (::vast::ll::Scope)","text":"<p>Scope, holds one region.</p> <p>Syntax:</p> <pre><code>operation ::= `ll.scope` $body attr-dict\n</code></pre> <p>Scope that holds one region, each block should be terminated                         with either branch, scope return or their conditional variants. Traits: NoRegionArguments</p>"},{"location":"dialects/LowLevel/LowLevel/#llscope_recurse-vastllscoperecurse","title":"<code>ll.scope_recurse</code> (::vast::ll::ScopeRecurse)","text":"<p>Jump to first block of scope.</p> <p>Syntax:</p> <pre><code>operation ::= `ll.scope_recurse` attr-dict\n</code></pre> <p>Modelling continue. Traits: Terminator</p>"},{"location":"dialects/LowLevel/LowLevel/#llscope_ret-vastllscoperet","title":"<code>ll.scope_ret</code> (::vast::ll::ScopeRet)","text":"<p>Terminator of scope.</p> <p>Syntax:</p> <pre><code>operation ::= `ll.scope_ret` attr-dict\n</code></pre> <p>Terminator of scopes (for example during lowering of loops). Traits: Terminator</p>"},{"location":"dialects/LowLevel/LowLevel/#lluninitialized_var-vastlluninitializedvar","title":"<code>ll.uninitialized_var</code> (::vast::ll::UninitializedVar)","text":"<p>Declaration of variable that have not been initialized yet.</p> <p>Syntax:</p> <pre><code>operation ::= `ll.uninitialized_var` attr-dict `:` type($result)\n</code></pre> <p>Declaration of variable that have not been initialized yet. Interfaces: VastSymbol</p>"},{"location":"dialects/LowLevel/LowLevel/#results_4","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/Meta/Meta/","title":"Meta","text":""},{"location":"dialects/Meta/Meta/#meta-dialect","title":"'meta' Dialect","text":"<p>A vast metadata dialect. This dialect intends capture user metadata that are kept accross transformations.</p> <ul> <li>'meta' Dialect<ul> <li>Attribute definition<ul> <li>IdentifierAttr<ul> <li>Parameters:</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"dialects/Meta/Meta/#attribute-definition","title":"Attribute definition","text":""},{"location":"dialects/Meta/Meta/#identifierattr","title":"IdentifierAttr","text":"<p>A metadata identifier.</p> <p>Syntax:</p> <pre><code>#meta.id&lt;\n  identifier_t   # value\n&gt;\n</code></pre> <p>A metadata identifier can be used to relate operations to external metadata storage.</p> <pre><code>#meta.id&lt;\"0x3A28213A\"&gt;\n</code></pre>"},{"location":"dialects/Meta/Meta/#parameters","title":"Parameters:","text":"Parameter C++ type Description value <code>identifier_t</code>"},{"location":"dialects/Unsupported/Unsupported/","title":"Unsupported","text":""},{"location":"dialects/Unsupported/Unsupported/#unsup-dialect","title":"'unsup' Dialect","text":"<p>A vast unsupported dialect. This dialect defines a set of generic unsupported operation/types that can be used to lower AST Node that are yet not supported and can't be lowered by other dialects.</p> <ul> <li>'unsup' Dialect<ul> <li>Operation definition<ul> <li>unsup.decl (::vast::unsup::UnsupportedDecl)<ul> <li>Attributes:</li> </ul> </li> <li>unsup.stmt (::vast::unsup::UnsupportedStmt)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> </ul> </li> <li>Attribute definition<ul> <li>UnsupportedAttr<ul> <li>Parameters:</li> </ul> </li> </ul> </li> <li>Type definition<ul> <li>UnsupportedType<ul> <li>Parameters:</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"dialects/Unsupported/Unsupported/#operation-definition","title":"Operation definition","text":""},{"location":"dialects/Unsupported/Unsupported/#unsupdecl-vastunsupunsupporteddecl","title":"<code>unsup.decl</code> (::vast::unsup::UnsupportedDecl)","text":"<p>VAST unsupported decl</p> <p>Syntax:</p> <pre><code>operation ::= `unsup.decl` $name attr-dict `:` $body\n</code></pre> <p>VAST unsupported decl Traits: NoTerminator</p>"},{"location":"dialects/Unsupported/Unsupported/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute"},{"location":"dialects/Unsupported/Unsupported/#unsupstmt-vastunsupunsupportedstmt","title":"<code>unsup.stmt</code> (::vast::unsup::UnsupportedStmt)","text":"<p>VAST unsupported statement</p> <p>Syntax:</p> <pre><code>operation ::= `unsup.stmt` $name attr-dict `:` type($result) $children\n</code></pre> <p>VAST unsupported statement Traits: NoTerminator</p>"},{"location":"dialects/Unsupported/Unsupported/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute"},{"location":"dialects/Unsupported/Unsupported/#results","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"dialects/Unsupported/Unsupported/#attribute-definition","title":"Attribute definition","text":""},{"location":"dialects/Unsupported/Unsupported/#unsupportedattr","title":"UnsupportedAttr","text":"<p>Syntax:</p> <pre><code>#unsup.attr&lt;\n  ::mlir::StringAttr   # spelling\n&gt;\n</code></pre>"},{"location":"dialects/Unsupported/Unsupported/#parameters","title":"Parameters:","text":"Parameter C++ type Description spelling <code>::mlir::StringAttr</code>"},{"location":"dialects/Unsupported/Unsupported/#type-definition","title":"Type definition","text":""},{"location":"dialects/Unsupported/Unsupported/#unsupportedtype","title":"UnsupportedType","text":"<p>Syntax:</p> <pre><code>!unsup.type&lt;\n  ::llvm::StringRef   # originName\n&gt;\n</code></pre>"},{"location":"dialects/Unsupported/Unsupported/#parameters_1","title":"Parameters:","text":"Parameter C++ type Description originName <code>::llvm::StringRef</code>"}]}